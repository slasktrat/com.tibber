{"version":3,"file":"bundle.umd.js","sources":["../src/utils.ts","../src/cache.ts","../src/types/Cache.ts"],"sourcesContent":["import {\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  FieldNode,\n  FragmentDefinitionNode,\n} from 'graphql';\n\nexport function queryFromPojo(obj: any): DocumentNode {\n  const op: OperationDefinitionNode = {\n    kind: 'OperationDefinition',\n    operation: 'query',\n    name: {\n      kind: 'Name',\n      value: 'GeneratedClientQuery',\n    },\n    selectionSet: selectionSetFromObj(obj),\n  };\n\n  const out: DocumentNode = {\n    kind: 'Document',\n    definitions: [op],\n  };\n\n  return out;\n}\n\nexport function fragmentFromPojo(obj: any, typename?: string): DocumentNode {\n  const frag: FragmentDefinitionNode = {\n    kind: 'FragmentDefinition',\n    typeCondition: {\n      kind: 'NamedType',\n      name: {\n        kind: 'Name',\n        value: typename || '__FakeType',\n      },\n    },\n    name: {\n      kind: 'Name',\n      value: 'GeneratedClientQuery',\n    },\n    selectionSet: selectionSetFromObj(obj),\n  };\n\n  const out: DocumentNode = {\n    kind: 'Document',\n    definitions: [frag],\n  };\n\n  return out;\n}\n\nfunction selectionSetFromObj(obj: any): SelectionSetNode {\n  if (\n    typeof obj === 'number' ||\n    typeof obj === 'boolean' ||\n    typeof obj === 'string' ||\n    typeof obj === 'undefined' ||\n    obj === null\n  ) {\n    // No selection set here\n    return null;\n  }\n\n  if (Array.isArray(obj)) {\n    // GraphQL queries don't include arrays\n    return selectionSetFromObj(obj[0]);\n  }\n\n  // Now we know it's an object\n  const selections: FieldNode[] = [];\n\n  Object.keys(obj).forEach(key => {\n    const nestedSelSet: SelectionSetNode = selectionSetFromObj(obj[key]);\n\n    const field: FieldNode = {\n      kind: 'Field',\n      name: {\n        kind: 'Name',\n        value: key,\n      },\n      selectionSet: nestedSelSet || undefined,\n    };\n\n    selections.push(field);\n  });\n\n  const selectionSet: SelectionSetNode = {\n    kind: 'SelectionSet',\n    selections,\n  };\n\n  return selectionSet;\n}\n\nexport const justTypenameQuery: DocumentNode = {\n  kind: 'Document',\n  definitions: [\n    {\n      kind: 'OperationDefinition',\n      operation: 'query',\n      name: null,\n      variableDefinitions: null,\n      directives: [],\n      selectionSet: {\n        kind: 'SelectionSet',\n        selections: [\n          {\n            kind: 'Field',\n            alias: null,\n            name: {\n              kind: 'Name',\n              value: '__typename',\n            },\n            arguments: [],\n            directives: [],\n            selectionSet: null,\n          },\n        ],\n      },\n    },\n  ],\n};\n","import { DocumentNode } from 'graphql';\nimport { getFragmentQueryDocument } from 'apollo-utilities';\n\nimport { DataProxy, Cache } from './types';\nimport { justTypenameQuery, queryFromPojo, fragmentFromPojo } from './utils';\n\nexport type Transaction<T> = (c: ApolloCache<T>) => void;\n\nexport abstract class ApolloCache<TSerialized> implements DataProxy {\n  // required to implement\n  // core API\n  public abstract read<T, TVariables = any>(\n    query: Cache.ReadOptions<TVariables>,\n  ): T | null;\n  public abstract write<TResult = any, TVariables = any>(\n    write: Cache.WriteOptions<TResult, TVariables>,\n  ): void;\n  public abstract diff<T>(query: Cache.DiffOptions): Cache.DiffResult<T>;\n  public abstract watch(watch: Cache.WatchOptions): () => void;\n  public abstract evict<TVariables = any>(\n    query: Cache.EvictOptions<TVariables>,\n  ): Cache.EvictionResult;\n  public abstract reset(): Promise<void>;\n\n  // intializer / offline / ssr API\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public abstract restore(\n    serializedState: TSerialized,\n  ): ApolloCache<TSerialized>;\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public abstract extract(optimistic?: boolean): TSerialized;\n\n  // optimistic API\n  public abstract removeOptimistic(id: string): void;\n\n  // transactional API\n  public abstract performTransaction(\n    transaction: Transaction<TSerialized>,\n  ): void;\n  public abstract recordOptimisticTransaction(\n    transaction: Transaction<TSerialized>,\n    id: string,\n  ): void;\n\n  // optional API\n  public transformDocument(document: DocumentNode): DocumentNode {\n    return document;\n  }\n  // experimental\n  public transformForLink(document: DocumentNode): DocumentNode {\n    return document;\n  }\n\n  // DataProxy API\n  /**\n   *\n   * @param options\n   * @param optimistic\n   */\n  public readQuery<QueryType, TVariables = any>(\n    options: DataProxy.Query<TVariables>,\n    optimistic: boolean = false,\n  ): QueryType | null {\n    return this.read({\n      query: options.query,\n      variables: options.variables,\n      optimistic,\n    });\n  }\n\n  public readFragment<FragmentType, TVariables = any>(\n    options: DataProxy.Fragment<TVariables>,\n    optimistic: boolean = false,\n  ): FragmentType | null {\n    return this.read({\n      query: getFragmentQueryDocument(options.fragment, options.fragmentName),\n      variables: options.variables,\n      rootId: options.id,\n      optimistic,\n    });\n  }\n\n  public writeQuery<TData = any, TVariables = any>(\n    options: Cache.WriteQueryOptions<TData, TVariables>,\n  ): void {\n    this.write({\n      dataId: 'ROOT_QUERY',\n      result: options.data,\n      query: options.query,\n      variables: options.variables,\n    });\n  }\n\n  public writeFragment<TData = any, TVariables = any>(\n    options: Cache.WriteFragmentOptions<TData, TVariables>,\n  ): void {\n    this.write({\n      dataId: options.id,\n      result: options.data,\n      variables: options.variables,\n      query: getFragmentQueryDocument(options.fragment, options.fragmentName),\n    });\n  }\n\n  public writeData<TData = any>({\n    id,\n    data,\n  }: Cache.WriteDataOptions<TData>): void {\n    if (typeof id !== 'undefined') {\n      let typenameResult = null;\n      // Since we can't use fragments without having a typename in the store,\n      // we need to make sure we have one.\n      // To avoid overwriting an existing typename, we need to read it out first\n      // and generate a fake one if none exists.\n      try {\n        typenameResult = this.read<any>({\n          rootId: id,\n          optimistic: false,\n          query: justTypenameQuery,\n        });\n      } catch (e) {\n        // Do nothing, since an error just means no typename exists\n      }\n\n      // tslint:disable-next-line\n      const __typename =\n        (typenameResult && typenameResult.__typename) || '__ClientData';\n\n      // Add a type here to satisfy the inmemory cache\n      const dataToWrite = Object.assign({ __typename }, data);\n\n      this.writeFragment({\n        id,\n        fragment: fragmentFromPojo(dataToWrite, __typename),\n        data: dataToWrite,\n      });\n    } else {\n      this.writeQuery({ query: queryFromPojo(data), data });\n    }\n  }\n}\n","import { DataProxy } from './DataProxy';\n\nexport namespace Cache {\n  export type WatchCallback = (newData: any) => void;\n  export interface EvictionResult {\n    success: Boolean;\n  }\n\n  export interface ReadOptions<TVariables = any>\n    extends DataProxy.Query<TVariables> {\n    rootId?: string;\n    previousResult?: any;\n    optimistic: boolean;\n  }\n\n  export interface WriteOptions<TResult = any, TVariables = any>\n    extends DataProxy.Query<TVariables> {\n    dataId: string;\n    result: TResult;\n  }\n\n  export interface DiffOptions extends ReadOptions {\n    returnPartialData?: boolean;\n  }\n\n  export interface WatchOptions extends ReadOptions {\n    callback: WatchCallback;\n  }\n\n  export interface EvictOptions<TVariables = any>\n    extends DataProxy.Query<TVariables> {\n    rootId?: string;\n  }\n\n  export import DiffResult = DataProxy.DiffResult;\n  export import WriteQueryOptions = DataProxy.WriteQueryOptions;\n  export import WriteFragmentOptions = DataProxy.WriteFragmentOptions;\n  export import WriteDataOptions = DataProxy.WriteDataOptions;\n  export import Fragment = DataProxy.Fragment;\n}\n"],"names":["getFragmentQueryDocument","Cache"],"mappings":";;;;;;aAQgB,aAAa,CAAC,GAAQ;QACpC,IAAM,EAAE,GAA4B;YAClC,IAAI,EAAE,qBAAqB;YAC3B,SAAS,EAAE,OAAO;YAClB,IAAI,EAAE;gBACJ,IAAI,EAAE,MAAM;gBACZ,KAAK,EAAE,sBAAsB;aAC9B;YACD,YAAY,EAAE,mBAAmB,CAAC,GAAG,CAAC;SACvC,CAAC;QAEF,IAAM,GAAG,GAAiB;YACxB,IAAI,EAAE,UAAU;YAChB,WAAW,EAAE,CAAC,EAAE,CAAC;SAClB,CAAC;QAEF,OAAO,GAAG,CAAC;IACb,CAAC;AAED,aAAgB,gBAAgB,CAAC,GAAQ,EAAE,QAAiB;QAC1D,IAAM,IAAI,GAA2B;YACnC,IAAI,EAAE,oBAAoB;YAC1B,aAAa,EAAE;gBACb,IAAI,EAAE,WAAW;gBACjB,IAAI,EAAE;oBACJ,IAAI,EAAE,MAAM;oBACZ,KAAK,EAAE,QAAQ,IAAI,YAAY;iBAChC;aACF;YACD,IAAI,EAAE;gBACJ,IAAI,EAAE,MAAM;gBACZ,KAAK,EAAE,sBAAsB;aAC9B;YACD,YAAY,EAAE,mBAAmB,CAAC,GAAG,CAAC;SACvC,CAAC;QAEF,IAAM,GAAG,GAAiB;YACxB,IAAI,EAAE,UAAU;YAChB,WAAW,EAAE,CAAC,IAAI,CAAC;SACpB,CAAC;QAEF,OAAO,GAAG,CAAC;IACb,CAAC;IAED,SAAS,mBAAmB,CAAC,GAAQ;QACnC,IACE,OAAO,GAAG,KAAK,QAAQ;YACvB,OAAO,GAAG,KAAK,SAAS;YACxB,OAAO,GAAG,KAAK,QAAQ;YACvB,OAAO,GAAG,KAAK,WAAW;YAC1B,GAAG,KAAK,IAAI,EACZ;YAEA,OAAO,IAAI,CAAC;SACb;QAED,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;YAEtB,OAAO,mBAAmB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;SACpC;QAGD,IAAM,UAAU,GAAgB,EAAE,CAAC;QAEnC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,UAAA,GAAG;YAC1B,IAAM,YAAY,GAAqB,mBAAmB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;YAErE,IAAM,KAAK,GAAc;gBACvB,IAAI,EAAE,OAAO;gBACb,IAAI,EAAE;oBACJ,IAAI,EAAE,MAAM;oBACZ,KAAK,EAAE,GAAG;iBACX;gBACD,YAAY,EAAE,YAAY,IAAI,SAAS;aACxC,CAAC;YAEF,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACxB,CAAC,CAAC;QAEH,IAAM,YAAY,GAAqB;YACrC,IAAI,EAAE,cAAc;YACpB,UAAU,YAAA;SACX,CAAC;QAEF,OAAO,YAAY,CAAC;IACtB,CAAC;AAED,IAAO,IAAM,iBAAiB,GAAiB;QAC7C,IAAI,EAAE,UAAU;QAChB,WAAW,EAAE;YACX;gBACE,IAAI,EAAE,qBAAqB;gBAC3B,SAAS,EAAE,OAAO;gBAClB,IAAI,EAAE,IAAI;gBACV,mBAAmB,EAAE,IAAI;gBACzB,UAAU,EAAE,EAAE;gBACd,YAAY,EAAE;oBACZ,IAAI,EAAE,cAAc;oBACpB,UAAU,EAAE;wBACV;4BACE,IAAI,EAAE,OAAO;4BACb,KAAK,EAAE,IAAI;4BACX,IAAI,EAAE;gCACJ,IAAI,EAAE,MAAM;gCACZ,KAAK,EAAE,YAAY;6BACpB;4BACD,SAAS,EAAE,EAAE;4BACb,UAAU,EAAE,EAAE;4BACd,YAAY,EAAE,IAAI;yBACnB;qBACF;iBACF;aACF;SACF;KACF,CAAC;;;QClHF;SA6IC;QA/FQ,uCAAiB,GAAxB,UAAyB,QAAsB;YAC7C,OAAO,QAAQ,CAAC;SACjB;QAEM,sCAAgB,GAAvB,UAAwB,QAAsB;YAC5C,OAAO,QAAQ,CAAC;SACjB;QAQM,+BAAS,GAAhB,UACE,OAAoC,EACpC,UAA2B;YAA3B,2BAAA,EAAA,kBAA2B;YAE3B,OAAO,IAAI,CAAC,IAAI,CAAC;gBACf,KAAK,EAAE,OAAO,CAAC,KAAK;gBACpB,SAAS,EAAE,OAAO,CAAC,SAAS;gBAC5B,UAAU,YAAA;aACX,CAAC,CAAC;SACJ;QAEM,kCAAY,GAAnB,UACE,OAAuC,EACvC,UAA2B;YAA3B,2BAAA,EAAA,kBAA2B;YAE3B,OAAO,IAAI,CAAC,IAAI,CAAC;gBACf,KAAK,EAAEA,wCAAwB,CAAC,OAAO,CAAC,QAAQ,EAAE,OAAO,CAAC,YAAY,CAAC;gBACvE,SAAS,EAAE,OAAO,CAAC,SAAS;gBAC5B,MAAM,EAAE,OAAO,CAAC,EAAE;gBAClB,UAAU,YAAA;aACX,CAAC,CAAC;SACJ;QAEM,gCAAU,GAAjB,UACE,OAAmD;YAEnD,IAAI,CAAC,KAAK,CAAC;gBACT,MAAM,EAAE,YAAY;gBACpB,MAAM,EAAE,OAAO,CAAC,IAAI;gBACpB,KAAK,EAAE,OAAO,CAAC,KAAK;gBACpB,SAAS,EAAE,OAAO,CAAC,SAAS;aAC7B,CAAC,CAAC;SACJ;QAEM,mCAAa,GAApB,UACE,OAAsD;YAEtD,IAAI,CAAC,KAAK,CAAC;gBACT,MAAM,EAAE,OAAO,CAAC,EAAE;gBAClB,MAAM,EAAE,OAAO,CAAC,IAAI;gBACpB,SAAS,EAAE,OAAO,CAAC,SAAS;gBAC5B,KAAK,EAAEA,wCAAwB,CAAC,OAAO,CAAC,QAAQ,EAAE,OAAO,CAAC,YAAY,CAAC;aACxE,CAAC,CAAC;SACJ;QAEM,+BAAS,GAAhB,UAA8B,EAGE;gBAF9B,UAAE,EACF,cAAI;YAEJ,IAAI,OAAO,EAAE,KAAK,WAAW,EAAE;gBAC7B,IAAI,cAAc,GAAG,IAAI,CAAC;gBAK1B,IAAI;oBACF,cAAc,GAAG,IAAI,CAAC,IAAI,CAAM;wBAC9B,MAAM,EAAE,EAAE;wBACV,UAAU,EAAE,KAAK;wBACjB,KAAK,EAAE,iBAAiB;qBACzB,CAAC,CAAC;iBACJ;gBAAC,OAAO,CAAC,EAAE;iBAEX;gBAGD,IAAM,UAAU,GACd,CAAC,cAAc,IAAI,cAAc,CAAC,UAAU,KAAK,cAAc,CAAC;gBAGlE,IAAM,WAAW,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,UAAU,YAAA,EAAE,EAAE,IAAI,CAAC,CAAC;gBAExD,IAAI,CAAC,aAAa,CAAC;oBACjB,EAAE,IAAA;oBACF,QAAQ,EAAE,gBAAgB,CAAC,WAAW,EAAE,UAAU,CAAC;oBACnD,IAAI,EAAE,WAAW;iBAClB,CAAC,CAAC;aACJ;iBAAM;gBACL,IAAI,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,aAAa,CAAC,IAAI,CAAC,EAAE,IAAI,MAAA,EAAE,CAAC,CAAC;aACvD;SACF;QACH,kBAAC;IAAD,CAAC;;ICnJD,WAAiB,KAAK;IAqCtB,CAAC,EArCgBC,aAAK,KAALA,aAAK,QAqCrB;;;;;;;;;;;;"}