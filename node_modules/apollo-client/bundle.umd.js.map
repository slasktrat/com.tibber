{"version":3,"file":"bundle.umd.js","sources":["../src/core/networkStatus.ts","../src/util/Observable.ts","../src/errors/ApolloError.ts","../src/core/types.ts","../src/core/ObservableQuery.ts","../src/scheduler/scheduler.ts","../src/data/mutations.ts","../src/data/queries.ts","../src/core/QueryManager.ts","../src/data/store.ts","../src/version.ts","../src/ApolloClient.ts"],"sourcesContent":["/**\n * The current status of a queryâ€™s execution in our system.\n */\nexport enum NetworkStatus {\n  /**\n   * The query has never been run before and the query is now currently running. A query will still\n   * have this network status even if a partial data result was returned from the cache, but a\n   * query was dispatched anyway.\n   */\n  loading = 1,\n\n  /**\n   * If `setVariables` was called and a query was fired because of that then the network status\n   * will be `setVariables` until the result of that query comes back.\n   */\n  setVariables = 2,\n\n  /**\n   * Indicates that `fetchMore` was called on this query and that the query created is currently in\n   * flight.\n   */\n  fetchMore = 3,\n\n  /**\n   * Similar to the `setVariables` network status. It means that `refetch` was called on a query\n   * and the refetch request is currently in flight.\n   */\n  refetch = 4,\n\n  /**\n   * Indicates that a polling query is currently in flight. So for example if you are polling a\n   * query every 10 seconds then the network status will switch to `poll` every 10 seconds whenever\n   * a poll request has been sent but not resolved.\n   */\n  poll = 6,\n\n  /**\n   * No request is in flight for this query, and no errors happened. Everything is OK.\n   */\n  ready = 7,\n\n  /**\n   * No request is in flight for this query, but one or more errors were detected.\n   */\n  error = 8,\n}\n\n/**\n * Returns true if there is currently a network request in flight according to a given network\n * status.\n */\nexport function isNetworkRequestInFlight(\n  networkStatus: NetworkStatus,\n): boolean {\n  return networkStatus < 7;\n}\n","// This simplified polyfill attempts to follow the ECMAScript Observable proposal.\n// See https://github.com/zenparsing/es-observable\nimport { Observable as LinkObservable } from 'apollo-link';\n\nexport type Subscription = ZenObservable.Subscription;\nexport type Observer<T> = ZenObservable.Observer<T>;\n\nimport $$observable from 'symbol-observable';\n\n// rxjs interopt\nexport class Observable<T> extends LinkObservable<T> {\n  public [$$observable]() {\n    return this;\n  }\n\n  public ['@@observable' as any]() {\n    return this;\n  }\n}\n","import { GraphQLError } from 'graphql';\n\nexport function isApolloError(err: Error): err is ApolloError {\n  return err.hasOwnProperty('graphQLErrors');\n}\n\n// Sets the error message on this error according to the\n// the GraphQL and network errors that are present.\n// If the error message has already been set through the\n// constructor or otherwise, this function is a nop.\nconst generateErrorMessage = (err: ApolloError) => {\n  let message = '';\n  // If we have GraphQL errors present, add that to the error message.\n  if (Array.isArray(err.graphQLErrors) && err.graphQLErrors.length !== 0) {\n    err.graphQLErrors.forEach((graphQLError: GraphQLError) => {\n      const errorMessage = graphQLError\n        ? graphQLError.message\n        : 'Error message not found.';\n      message += `GraphQL error: ${errorMessage}\\n`;\n    });\n  }\n\n  if (err.networkError) {\n    message += 'Network error: ' + err.networkError.message + '\\n';\n  }\n\n  // strip newline from the end of the message\n  message = message.replace(/\\n$/, '');\n  return message;\n};\n\nexport class ApolloError extends Error {\n  public message: string;\n  public graphQLErrors: GraphQLError[];\n  public networkError: Error | null;\n\n  // An object that can be used to provide some additional information\n  // about an error, e.g. specifying the type of error this is. Used\n  // internally within Apollo Client.\n  public extraInfo: any;\n\n  // Constructs an instance of ApolloError given a GraphQLError\n  // or a network error. Note that one of these has to be a valid\n  // value or the constructed error will be meaningless.\n  constructor({\n    graphQLErrors,\n    networkError,\n    errorMessage,\n    extraInfo,\n  }: {\n    graphQLErrors?: GraphQLError[];\n    networkError?: Error | null;\n    errorMessage?: string;\n    extraInfo?: any;\n  }) {\n    super(errorMessage);\n    this.graphQLErrors = graphQLErrors || [];\n    this.networkError = networkError || null;\n\n    if (!errorMessage) {\n      this.message = generateErrorMessage(this);\n    } else {\n      this.message = errorMessage;\n    }\n\n    this.extraInfo = extraInfo;\n\n    // We're not using `Object.setPrototypeOf` here as it isn't fully\n    // supported on Android (see issue #3236).\n    (this as any).__proto__ = ApolloError.prototype;\n  }\n}\n","import { DocumentNode, GraphQLError } from 'graphql';\nimport { QueryStoreValue } from '../data/queries';\nimport { NetworkStatus } from './networkStatus';\nimport { FetchResult } from 'apollo-link';\n\nexport type QueryListener = (\n  queryStoreValue: QueryStoreValue,\n  newData?: any,\n) => void;\n\nexport type OperationVariables = { [key: string]: any };\n\nexport type PureQueryOptions = {\n  query: DocumentNode;\n  variables?: { [key: string]: any };\n  context?: any;\n};\n\nexport type ApolloQueryResult<T> = {\n  data: T;\n  errors?: GraphQLError[];\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  stale: boolean;\n};\n\nexport enum FetchType {\n  normal = 1,\n  refetch = 2,\n  poll = 3,\n}\n\n// This is part of the public API, people write these functions in `updateQueries`.\nexport type MutationQueryReducer<T> = (\n  previousResult: Record<string, any>,\n  options: {\n    mutationResult: FetchResult<T>;\n    queryName: string | undefined;\n    queryVariables: Record<string, any>;\n  },\n) => Record<string, any>;\n\nexport type MutationQueryReducersMap<T = { [key: string]: any }> = {\n  [queryName: string]: MutationQueryReducer<T>;\n};\n","import { isEqual, tryFunctionOrLogError } from 'apollo-utilities';\nimport { GraphQLError } from 'graphql';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport { Observable, Observer, Subscription } from '../util/Observable';\n\nimport { QueryScheduler } from '../scheduler/scheduler';\n\nimport { ApolloError } from '../errors/ApolloError';\n\nimport { QueryManager } from './QueryManager';\nimport { ApolloQueryResult, FetchType, OperationVariables } from './types';\nimport {\n  ModifiableWatchQueryOptions,\n  WatchQueryOptions,\n  FetchMoreQueryOptions,\n  SubscribeToMoreOptions,\n  ErrorPolicy,\n  UpdateQueryFn,\n} from './watchQueryOptions';\n\nimport { QueryStoreValue } from '../data/queries';\n\nexport type ApolloCurrentResult<T> = {\n  data: T | {};\n  errors?: GraphQLError[];\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  error?: ApolloError;\n  partial?: boolean;\n};\n\nexport interface FetchMoreOptions<\n  TData = any,\n  TVariables = OperationVariables\n> {\n  updateQuery: (\n    previousQueryResult: TData,\n    options: {\n      fetchMoreResult?: TData;\n      variables?: TVariables;\n    },\n  ) => TData;\n}\n\nexport interface UpdateQueryOptions<TVariables> {\n  variables?: TVariables;\n}\n\nexport const hasError = (\n  storeValue: QueryStoreValue,\n  policy: ErrorPolicy = 'none',\n) =>\n  storeValue &&\n  ((storeValue.graphQLErrors &&\n    storeValue.graphQLErrors.length > 0 &&\n    policy === 'none') ||\n    storeValue.networkError);\n\nexport class ObservableQuery<\n  TData = any,\n  TVariables = OperationVariables\n> extends Observable<ApolloQueryResult<TData>> {\n  public options: WatchQueryOptions<TVariables>;\n  public queryId: string;\n  /**\n   *\n   * The current value of the variables for this query. Can change.\n   */\n  public variables: TVariables;\n\n  private isCurrentlyPolling: boolean;\n  private shouldSubscribe: boolean;\n  private isTornDown: boolean;\n  private scheduler: QueryScheduler<any>;\n  private queryManager: QueryManager<any>;\n  private observers: Observer<ApolloQueryResult<TData>>[];\n  private subscriptionHandles: Subscription[];\n\n  private lastResult: ApolloQueryResult<TData>;\n  private lastError: ApolloError;\n\n  constructor({\n    scheduler,\n    options,\n    shouldSubscribe = true,\n  }: {\n    scheduler: QueryScheduler<any>;\n    options: WatchQueryOptions<TVariables>;\n    shouldSubscribe?: boolean;\n  }) {\n    super((observer: Observer<ApolloQueryResult<TData>>) =>\n      this.onSubscribe(observer),\n    );\n\n    // active state\n    this.isCurrentlyPolling = false;\n    this.isTornDown = false;\n\n    // query information\n    this.options = options;\n    this.variables = options.variables || ({} as TVariables);\n    this.queryId = scheduler.queryManager.generateQueryId();\n    this.shouldSubscribe = shouldSubscribe;\n\n    // related classes\n    this.scheduler = scheduler;\n    this.queryManager = scheduler.queryManager;\n\n    // interal data stores\n    this.observers = [];\n    this.subscriptionHandles = [];\n  }\n\n  public result(): Promise<ApolloQueryResult<TData>> {\n    const that = this;\n    return new Promise((resolve, reject) => {\n      let subscription: Subscription;\n      const observer: Observer<ApolloQueryResult<TData>> = {\n        next(result: ApolloQueryResult<TData>) {\n          resolve(result);\n\n          // Stop the query within the QueryManager if we can before\n          // this function returns.\n          //\n          // We do this in order to prevent observers piling up within\n          // the QueryManager. Notice that we only fully unsubscribe\n          // from the subscription in a setTimeout(..., 0)  call. This call can\n          // actually be handled by the browser at a much later time. If queries\n          // are fired in the meantime, observers that should have been removed\n          // from the QueryManager will continue to fire, causing an unnecessary\n          // performance hit.\n          if (!that.observers.some(obs => obs !== observer)) {\n            that.queryManager.removeQuery(that.queryId);\n          }\n\n          setTimeout(() => {\n            subscription.unsubscribe();\n          }, 0);\n        },\n        error(error: any) {\n          reject(error);\n        },\n      };\n      subscription = that.subscribe(observer);\n    });\n  }\n\n  /**\n   * Return the result of the query from the local cache as well as some fetching status\n   * `loading` and `networkStatus` allow to know if a request is in flight\n   * `partial` lets you know if the result from the local cache is complete or partial\n   * @return {data: Object, error: ApolloError, loading: boolean, networkStatus: number, partial: boolean}\n   */\n  public currentResult(): ApolloCurrentResult<TData> {\n    if (this.isTornDown) {\n      return {\n        data: this.lastError ? {} : this.lastResult ? this.lastResult.data : {},\n        error: this.lastError,\n        loading: false,\n        networkStatus: NetworkStatus.error,\n      };\n    }\n\n    const queryStoreValue = this.queryManager.queryStore.get(this.queryId);\n\n    if (hasError(queryStoreValue, this.options.errorPolicy)) {\n      return {\n        data: {},\n        loading: false,\n        networkStatus: queryStoreValue.networkStatus,\n        error: new ApolloError({\n          graphQLErrors: queryStoreValue.graphQLErrors,\n          networkError: queryStoreValue.networkError,\n        }),\n      };\n    }\n\n    const { data, partial } = this.queryManager.getCurrentQueryResult(this);\n\n    const queryLoading =\n      !queryStoreValue ||\n      queryStoreValue.networkStatus === NetworkStatus.loading;\n\n    // We need to be careful about the loading state we show to the user, to try\n    // and be vaguely in line with what the user would have seen from .subscribe()\n    // but to still provide useful information synchronously when the query\n    // will not end up hitting the server.\n    // See more: https://github.com/apollostack/apollo-client/issues/707\n    // Basically: is there a query in flight right now (modolo the next tick)?\n    const loading =\n      (this.options.fetchPolicy === 'network-only' && queryLoading) ||\n      (partial && this.options.fetchPolicy !== 'cache-only');\n\n    // if there is nothing in the query store, it means this query hasn't fired yet or it has been cleaned up. Therefore the\n    // network status is dependent on queryLoading.\n    let networkStatus: NetworkStatus;\n    if (queryStoreValue) {\n      networkStatus = queryStoreValue.networkStatus;\n    } else {\n      networkStatus = loading ? NetworkStatus.loading : NetworkStatus.ready;\n    }\n\n    const result = {\n      data,\n      loading: isNetworkRequestInFlight(networkStatus),\n      networkStatus,\n    } as ApolloQueryResult<TData>;\n\n    if (\n      queryStoreValue &&\n      queryStoreValue.graphQLErrors &&\n      this.options.errorPolicy === 'all'\n    ) {\n      result.errors = queryStoreValue.graphQLErrors;\n    }\n\n    if (!partial) {\n      const stale = false;\n      this.lastResult = { ...result, stale };\n    }\n\n    return { ...result, partial } as ApolloCurrentResult<TData>;\n  }\n\n  // Returns the last result that observer.next was called with. This is not the same as\n  // currentResult! If you're not sure which you need, then you probably need currentResult.\n  public getLastResult(): ApolloQueryResult<TData> {\n    return this.lastResult;\n  }\n\n  public getLastError(): ApolloError {\n    return this.lastError;\n  }\n\n  public resetLastResults(): void {\n    delete this.lastResult;\n    delete this.lastError;\n    this.isTornDown = false;\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results.\n   * This method should be preferred over `setVariables` in most use cases.\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public refetch(variables?: TVariables): Promise<ApolloQueryResult<TData>> {\n    const { fetchPolicy } = this.options;\n    // early return if trying to read from cache during refetch\n    if (fetchPolicy === 'cache-only') {\n      return Promise.reject(\n        new Error(\n          'cache-only fetchPolicy option should not be used together with query refetch.',\n        ),\n      );\n    }\n\n    if (!isEqual(this.variables, variables)) {\n      // update observable variables\n      this.variables = Object.assign({}, this.variables, variables);\n    }\n\n    if (!isEqual(this.options.variables, this.variables)) {\n      // Update the existing options with new variables\n      this.options.variables = Object.assign(\n        {},\n        this.options.variables,\n        this.variables,\n      );\n    }\n\n    // Override fetchPolicy for this call only\n    // only network-only and no-cache are safe to use\n    const isNetworkFetchPolicy =\n      fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';\n\n    const combinedOptions: WatchQueryOptions = {\n      ...this.options,\n      fetchPolicy: isNetworkFetchPolicy ? fetchPolicy : 'network-only',\n    };\n\n    return this.queryManager\n      .fetchQuery(this.queryId, combinedOptions, FetchType.refetch)\n      .then(result => result as ApolloQueryResult<TData>);\n  }\n\n  public fetchMore<K extends keyof TVariables>(\n    fetchMoreOptions: FetchMoreQueryOptions<TVariables, K> &\n      FetchMoreOptions<TData, TVariables>,\n  ): Promise<ApolloQueryResult<TData>> {\n    // early return if no update Query\n    if (!fetchMoreOptions.updateQuery) {\n      throw new Error(\n        'updateQuery option is required. This function defines how to update the query data with the new results.',\n      );\n    }\n\n    let combinedOptions: any;\n\n    return Promise.resolve()\n      .then(() => {\n        const qid = this.queryManager.generateQueryId();\n\n        if (fetchMoreOptions.query) {\n          // fetch a new query\n          combinedOptions = fetchMoreOptions;\n        } else {\n          // fetch the same query with a possibly new variables\n          combinedOptions = {\n            ...this.options,\n            ...fetchMoreOptions,\n            variables: Object.assign(\n              {},\n              this.variables,\n              fetchMoreOptions.variables,\n            ),\n          };\n        }\n\n        combinedOptions.fetchPolicy = 'network-only';\n\n        return this.queryManager.fetchQuery(\n          qid,\n          combinedOptions as WatchQueryOptions,\n          FetchType.normal,\n          this.queryId,\n        );\n      })\n      .then(fetchMoreResult => {\n        this.updateQuery((previousResult: any) =>\n          fetchMoreOptions.updateQuery(previousResult, {\n            fetchMoreResult: fetchMoreResult.data as TData,\n            variables: combinedOptions.variables,\n          }),\n        );\n\n        return fetchMoreResult as ApolloQueryResult<TData>;\n      });\n  }\n\n  // XXX the subscription variables are separate from the query variables.\n  // if you want to update subscription variables, right now you have to do that separately,\n  // and you can only do it by stopping the subscription and then subscribing again with new variables.\n  public subscribeToMore(options: SubscribeToMoreOptions<TData, TVariables>) {\n    const subscription = this.queryManager\n      .startGraphQLSubscription({\n        query: options.document,\n        variables: options.variables,\n      })\n      .subscribe({\n        next: (subscriptionData: { data: TData }) => {\n          if (options.updateQuery) {\n            this.updateQuery((previous, { variables }) =>\n              (options.updateQuery as UpdateQueryFn<TData, TVariables>)(\n                previous,\n                {\n                  subscriptionData,\n                  variables,\n                },\n              ),\n            );\n          }\n        },\n        error: (err: any) => {\n          if (options.onError) {\n            options.onError(err);\n            return;\n          }\n          console.error('Unhandled GraphQL subscription error', err);\n        },\n      });\n\n    this.subscriptionHandles.push(subscription);\n\n    return () => {\n      const i = this.subscriptionHandles.indexOf(subscription);\n      if (i >= 0) {\n        this.subscriptionHandles.splice(i, 1);\n        subscription.unsubscribe();\n      }\n    };\n  }\n\n  // Note: if the query is not active (there are no subscribers), the promise\n  // will return null immediately.\n  public setOptions(\n    opts: ModifiableWatchQueryOptions,\n  ): Promise<ApolloQueryResult<TData>> {\n    const oldOptions = this.options;\n    this.options = Object.assign({}, this.options, opts) as WatchQueryOptions<\n      TVariables\n    >;\n\n    if (opts.pollInterval) {\n      this.startPolling(opts.pollInterval);\n    } else if (opts.pollInterval === 0) {\n      this.stopPolling();\n    }\n\n    // If fetchPolicy went from cache-only to something else, or from something else to network-only\n    const tryFetch: boolean =\n      (oldOptions.fetchPolicy !== 'network-only' &&\n        opts.fetchPolicy === 'network-only') ||\n      (oldOptions.fetchPolicy === 'cache-only' &&\n        opts.fetchPolicy !== 'cache-only') ||\n      (oldOptions.fetchPolicy === 'standby' &&\n        opts.fetchPolicy !== 'standby') ||\n      false;\n\n    return this.setVariables(\n      this.options.variables as TVariables,\n      tryFetch,\n      opts.fetchResults,\n    );\n  }\n\n  /**\n   * This is for *internal* use only. Most users should instead use `refetch`\n   * in order to be properly notified of results even when they come from cache.\n   *\n   * Update the variables of this observable query, and fetch the new results\n   * if they've changed. If you want to force new results, use `refetch`.\n   *\n   * Note: the `next` callback will *not* fire if the variables have not changed\n   * or if the result is coming from cache.\n   *\n   * Note: the promise will return the old results immediately if the variables\n   * have not changed.\n   *\n   * Note: the promise will return null immediately if the query is not active\n   * (there are no subscribers).\n   *\n   * @private\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   *\n   * @param tryFetch: Try and fetch new results even if the variables haven't\n   * changed (we may still just hit the store, but if there's nothing in there\n   * this will refetch)\n   *\n   * @param fetchResults: Option to ignore fetching results when updating variables\n   */\n  public setVariables(\n    variables: TVariables,\n    tryFetch: boolean = false,\n    fetchResults = true,\n  ): Promise<ApolloQueryResult<TData>> {\n    // since setVariables restarts the subscription, we reset the tornDown status\n    this.isTornDown = false;\n\n    const newVariables = variables ? variables : this.variables;\n\n    if (isEqual(newVariables, this.variables) && !tryFetch) {\n      // If we have no observers, then we don't actually want to make a network\n      // request. As soon as someone observes the query, the request will kick\n      // off. For now, we just store any changes. (See #1077)\n      if (this.observers.length === 0 || !fetchResults) {\n        return new Promise(resolve => resolve());\n      }\n      return this.result();\n    } else {\n      this.variables = newVariables;\n      this.options.variables = newVariables;\n\n      // See comment above\n      if (this.observers.length === 0) {\n        return new Promise(resolve => resolve());\n      }\n\n      // Use the same options as before, but with new variables\n      return this.queryManager\n        .fetchQuery(this.queryId, {\n          ...this.options,\n          variables: this.variables,\n        } as WatchQueryOptions)\n        .then(result => result as ApolloQueryResult<TData>);\n    }\n  }\n\n  public updateQuery(\n    mapFn: (\n      previousQueryResult: TData,\n      options: UpdateQueryOptions<TVariables>,\n    ) => TData,\n  ): void {\n    const {\n      previousResult,\n      variables,\n      document,\n    } = this.queryManager.getQueryWithPreviousResult(this.queryId);\n\n    const newResult = tryFunctionOrLogError(() =>\n      mapFn(previousResult, { variables: variables as TVariables }),\n    );\n\n    if (newResult) {\n      this.queryManager.dataStore.markUpdateQueryResult(\n        document,\n        variables,\n        newResult,\n      );\n      this.queryManager.broadcastQueries();\n    }\n  }\n\n  public stopPolling() {\n    if (this.isCurrentlyPolling) {\n      this.scheduler.stopPollingQuery(this.queryId);\n      this.options.pollInterval = undefined;\n      this.isCurrentlyPolling = false;\n    }\n  }\n\n  public startPolling(pollInterval: number) {\n    if (\n      this.options.fetchPolicy === 'cache-first' ||\n      this.options.fetchPolicy === 'cache-only'\n    ) {\n      throw new Error(\n        'Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.',\n      );\n    }\n\n    if (this.isCurrentlyPolling) {\n      this.scheduler.stopPollingQuery(this.queryId);\n      this.isCurrentlyPolling = false;\n    }\n    this.options.pollInterval = pollInterval;\n    this.isCurrentlyPolling = true;\n    this.scheduler.startPollingQuery(this.options, this.queryId);\n  }\n\n  private onSubscribe(observer: Observer<ApolloQueryResult<TData>>) {\n    // Zen Observable has its own error function, in order to log correctly\n    // we need to declare a custom error if nothing is passed\n    if (\n      (observer as any)._subscription &&\n      (observer as any)._subscription._observer &&\n      !(observer as any)._subscription._observer.error\n    ) {\n      (observer as any)._subscription._observer.error = (\n        error: ApolloError,\n      ) => {\n        console.error('Unhandled error', error.message, error.stack);\n      };\n    }\n\n    this.observers.push(observer);\n\n    // Deliver initial result\n    if (observer.next && this.lastResult) observer.next(this.lastResult);\n    if (observer.error && this.lastError) observer.error(this.lastError);\n\n    // setup the query if it hasn't been done before\n    if (this.observers.length === 1) this.setUpQuery();\n\n    return () => {\n      this.observers = this.observers.filter(obs => obs !== observer);\n\n      if (this.observers.length === 0) {\n        this.tearDownQuery();\n      }\n    };\n  }\n\n  private setUpQuery() {\n    if (this.shouldSubscribe) {\n      this.queryManager.addObservableQuery<TData>(this.queryId, this);\n    }\n\n    if (!!this.options.pollInterval) {\n      if (\n        this.options.fetchPolicy === 'cache-first' ||\n        this.options.fetchPolicy === 'cache-only'\n      ) {\n        throw new Error(\n          'Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.',\n        );\n      }\n\n      this.isCurrentlyPolling = true;\n      this.scheduler.startPollingQuery<TData>(this.options, this.queryId);\n    }\n\n    const observer: Observer<ApolloQueryResult<TData>> = {\n      next: (result: ApolloQueryResult<TData>) => {\n        this.lastResult = result;\n        this.observers.forEach(obs => obs.next && obs.next(result));\n      },\n      error: (error: ApolloError) => {\n        this.lastError = error;\n        this.observers.forEach(obs => obs.error && obs.error(error));\n      },\n    };\n\n    this.queryManager.startQuery<TData>(\n      this.queryId,\n      this.options,\n      this.queryManager.queryListenerForObserver(\n        this.queryId,\n        this.options,\n        observer,\n      ),\n    );\n  }\n\n  private tearDownQuery() {\n    this.isTornDown = true;\n\n    if (this.isCurrentlyPolling) {\n      this.scheduler.stopPollingQuery(this.queryId);\n      this.isCurrentlyPolling = false;\n    }\n\n    // stop all active GraphQL subscriptions\n    this.subscriptionHandles.forEach(sub => sub.unsubscribe());\n    this.subscriptionHandles = [];\n\n    this.queryManager.removeObservableQuery(this.queryId);\n\n    this.queryManager.stopQuery(this.queryId);\n\n    this.observers = [];\n  }\n}\n","// The QueryScheduler is supposed to be a mechanism that schedules polling queries such that\n// they are clustered into the time slots of the QueryBatcher and are batched together. It\n// also makes sure that for a given polling query, if one instance of the query is inflight,\n// another instance will not be fired until the query returns or times out. We do this because\n// another query fires while one is already in flight, the data will stay in the \"loading\" state\n// even after the first query has returned.\n\n// At the moment, the QueryScheduler implements the one-polling-instance-at-a-time logic and\n// adds queries to the QueryBatcher queue.\n\nimport { QueryManager } from '../core/QueryManager';\n\nimport { FetchType, QueryListener } from '../core/types';\n\nimport { ObservableQuery } from '../core/ObservableQuery';\n\nimport { WatchQueryOptions } from '../core/watchQueryOptions';\n\nimport { NetworkStatus } from '../core/networkStatus';\n\nexport class QueryScheduler<TCacheShape> {\n  // Map going from queryIds to query options that are in flight.\n  public inFlightQueries: { [queryId: string]: WatchQueryOptions } = {};\n\n  // Map going from query ids to the query options associated with those queries. Contains all of\n  // the queries, both in flight and not in flight.\n  public registeredQueries: { [queryId: string]: WatchQueryOptions } = {};\n\n  // Map going from polling interval with to the query ids that fire on that interval.\n  // These query ids are associated with a set of options in the this.registeredQueries.\n  public intervalQueries: { [interval: number]: string[] } = {};\n\n  // We use this instance to actually fire queries (i.e. send them to the batching\n  // mechanism).\n  public queryManager: QueryManager<TCacheShape>;\n\n  // Map going from polling interval widths to polling timers.\n  private pollingTimers: { [interval: number]: any } = {};\n\n  private ssrMode: boolean = false;\n\n  constructor({\n    queryManager,\n    ssrMode,\n  }: {\n    queryManager: QueryManager<TCacheShape>;\n    ssrMode?: boolean;\n  }) {\n    this.queryManager = queryManager;\n    this.ssrMode = ssrMode || false;\n  }\n\n  public checkInFlight(queryId: string) {\n    const query = this.queryManager.queryStore.get(queryId);\n\n    return (\n      query &&\n      query.networkStatus !== NetworkStatus.ready &&\n      query.networkStatus !== NetworkStatus.error\n    );\n  }\n\n  public fetchQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    fetchType: FetchType,\n  ) {\n    return new Promise((resolve, reject) => {\n      this.queryManager\n        .fetchQuery<T>(queryId, options, fetchType)\n        .then(result => {\n          resolve(result);\n        })\n        .catch(error => {\n          reject(error);\n        });\n    });\n  }\n\n  public startPollingQuery<T>(\n    options: WatchQueryOptions,\n    queryId: string,\n    listener?: QueryListener,\n  ): string {\n    if (!options.pollInterval) {\n      throw new Error(\n        'Attempted to start a polling query without a polling interval.',\n      );\n    }\n\n    // Do not poll in SSR mode\n    if (this.ssrMode) return queryId;\n\n    this.registeredQueries[queryId] = options;\n\n    if (listener) {\n      this.queryManager.addQueryListener(queryId, listener);\n    }\n    this.addQueryOnInterval<T>(queryId, options);\n\n    return queryId;\n  }\n\n  public stopPollingQuery(queryId: string) {\n    // Remove the query options from one of the registered queries.\n    // The polling function will then take care of not firing it anymore.\n    delete this.registeredQueries[queryId];\n  }\n\n  // Fires the all of the queries on a particular interval. Called on a setInterval.\n  public fetchQueriesOnInterval<T>(interval: number) {\n    // XXX this \"filter\" here is nasty, because it does two things at the same time.\n    // 1. remove queries that have stopped polling\n    // 2. call fetchQueries for queries that are polling and not in flight.\n    // TODO: refactor this to make it cleaner\n    this.intervalQueries[interval] = this.intervalQueries[interval].filter(\n      queryId => {\n        // If queryOptions can't be found from registeredQueries or if it has a\n        // different interval, it means that this queryId is no longer registered\n        // and should be removed from the list of queries firing on this interval.\n        //\n        // We don't remove queries from intervalQueries immediately in\n        // stopPollingQuery so that we can keep the timer consistent when queries\n        // are removed and replaced, and to avoid quadratic behavior when stopping\n        // many queries.\n        if (\n          !(\n            this.registeredQueries.hasOwnProperty(queryId) &&\n            this.registeredQueries[queryId].pollInterval === interval\n          )\n        ) {\n          return false;\n        }\n\n        // Don't fire this instance of the polling query is one of the instances is already in\n        // flight.\n        if (this.checkInFlight(queryId)) {\n          return true;\n        }\n\n        const queryOptions = this.registeredQueries[queryId];\n        const pollingOptions = { ...queryOptions } as WatchQueryOptions;\n        pollingOptions.fetchPolicy = 'network-only';\n        // don't let unhandled rejections happen\n        this.fetchQuery<T>(queryId, pollingOptions, FetchType.poll).catch(\n          () => {},\n        );\n        return true;\n      },\n    );\n\n    if (this.intervalQueries[interval].length === 0) {\n      clearInterval(this.pollingTimers[interval]);\n      delete this.intervalQueries[interval];\n    }\n  }\n\n  // Adds a query on a particular interval to this.intervalQueries and then fires\n  // that query with all the other queries executing on that interval. Note that the query id\n  // and query options must have been added to this.registeredQueries before this function is called.\n  public addQueryOnInterval<T>(\n    queryId: string,\n    queryOptions: WatchQueryOptions,\n  ) {\n    const interval = queryOptions.pollInterval;\n\n    if (!interval) {\n      throw new Error(\n        `A poll interval is required to start polling query with id '${queryId}'.`,\n      );\n    }\n\n    // If there are other queries on this interval, this query will just fire with those\n    // and we don't need to create a new timer.\n    if (\n      this.intervalQueries.hasOwnProperty(interval.toString()) &&\n      this.intervalQueries[interval].length > 0\n    ) {\n      this.intervalQueries[interval].push(queryId);\n    } else {\n      this.intervalQueries[interval] = [queryId];\n      // set up the timer for the function that will handle this interval\n      this.pollingTimers[interval] = setInterval(() => {\n        this.fetchQueriesOnInterval<T>(interval);\n      }, interval);\n    }\n  }\n\n  // Used only for unit testing.\n  public registerPollingQuery<T>(\n    queryOptions: WatchQueryOptions,\n  ): ObservableQuery<T> {\n    if (!queryOptions.pollInterval) {\n      throw new Error(\n        'Attempted to register a non-polling query with the scheduler.',\n      );\n    }\n    return new ObservableQuery<T>({\n      scheduler: this,\n      options: queryOptions,\n    });\n  }\n}\n","export class MutationStore {\n  private store: { [mutationId: string]: MutationStoreValue } = {};\n\n  public getStore(): { [mutationId: string]: MutationStoreValue } {\n    return this.store;\n  }\n\n  public get(mutationId: string): MutationStoreValue {\n    return this.store[mutationId];\n  }\n\n  public initMutation(\n    mutationId: string,\n    mutationString: string,\n    variables: Object | undefined,\n  ) {\n    this.store[mutationId] = {\n      mutationString: mutationString,\n      variables: variables || {},\n      loading: true,\n      error: null,\n    };\n  }\n\n  public markMutationError(mutationId: string, error: Error) {\n    const mutation = this.store[mutationId];\n\n    if (!mutation) {\n      return;\n    }\n\n    mutation.loading = false;\n    mutation.error = error;\n  }\n\n  public markMutationResult(mutationId: string) {\n    const mutation = this.store[mutationId];\n\n    if (!mutation) {\n      return;\n    }\n\n    mutation.loading = false;\n    mutation.error = null;\n  }\n\n  public reset() {\n    this.store = {};\n  }\n}\n\nexport interface MutationStoreValue {\n  mutationString: string;\n  variables: Object;\n  loading: boolean;\n  error: Error | null;\n}\n","import { DocumentNode, GraphQLError, ExecutionResult } from 'graphql';\nimport { print } from 'graphql/language/printer';\nimport { isEqual } from 'apollo-utilities';\n\nimport { NetworkStatus } from '../core/networkStatus';\n\nexport type QueryStoreValue = {\n  document: DocumentNode;\n  variables: Object;\n  previousVariables?: Object | null;\n  networkStatus: NetworkStatus;\n  networkError?: Error | null;\n  graphQLErrors?: GraphQLError[];\n  metadata: any;\n};\n\nexport class QueryStore {\n  private store: { [queryId: string]: QueryStoreValue } = {};\n\n  public getStore(): { [queryId: string]: QueryStoreValue } {\n    return this.store;\n  }\n\n  public get(queryId: string): QueryStoreValue {\n    return this.store[queryId];\n  }\n\n  public initQuery(query: {\n    queryId: string;\n    document: DocumentNode;\n    storePreviousVariables: boolean;\n    variables: Object;\n    isPoll: boolean;\n    isRefetch: boolean;\n    metadata: any;\n    fetchMoreForQueryId: string | undefined;\n  }) {\n    const previousQuery = this.store[query.queryId];\n\n    if (\n      previousQuery &&\n      previousQuery.document !== query.document &&\n      print(previousQuery.document) !== print(query.document)\n    ) {\n      // XXX we're throwing an error here to catch bugs where a query gets overwritten by a new one.\n      // we should implement a separate action for refetching so that QUERY_INIT may never overwrite\n      // an existing query (see also: https://github.com/apollostack/apollo-client/issues/732)\n      throw new Error(\n        'Internal Error: may not update existing query string in store',\n      );\n    }\n\n    let isSetVariables = false;\n\n    let previousVariables: Object | null = null;\n    if (\n      query.storePreviousVariables &&\n      previousQuery &&\n      previousQuery.networkStatus !== NetworkStatus.loading\n      // if the previous query was still loading, we don't want to remember it at all.\n    ) {\n      if (!isEqual(previousQuery.variables, query.variables)) {\n        isSetVariables = true;\n        previousVariables = previousQuery.variables;\n      }\n    }\n\n    // TODO break this out into a separate function\n    let networkStatus;\n    if (isSetVariables) {\n      networkStatus = NetworkStatus.setVariables;\n    } else if (query.isPoll) {\n      networkStatus = NetworkStatus.poll;\n    } else if (query.isRefetch) {\n      networkStatus = NetworkStatus.refetch;\n      // TODO: can we determine setVariables here if it's a refetch and the variables have changed?\n    } else {\n      networkStatus = NetworkStatus.loading;\n    }\n\n    let graphQLErrors: GraphQLError[] = [];\n    if (previousQuery && previousQuery.graphQLErrors) {\n      graphQLErrors = previousQuery.graphQLErrors;\n    }\n\n    // XXX right now if QUERY_INIT is fired twice, like in a refetch situation, we just overwrite\n    // the store. We probably want a refetch action instead, because I suspect that if you refetch\n    // before the initial fetch is done, you'll get an error.\n    this.store[query.queryId] = {\n      document: query.document,\n      variables: query.variables,\n      previousVariables,\n      networkError: null,\n      graphQLErrors: graphQLErrors,\n      networkStatus,\n      metadata: query.metadata,\n    };\n\n    // If the action had a `moreForQueryId` property then we need to set the\n    // network status on that query as well to `fetchMore`.\n    //\n    // We have a complement to this if statement in the query result and query\n    // error action branch, but importantly *not* in the client result branch.\n    // This is because the implementation of `fetchMore` *always* sets\n    // `fetchPolicy` to `network-only` so we would never have a client result.\n    if (\n      typeof query.fetchMoreForQueryId === 'string' &&\n      this.store[query.fetchMoreForQueryId]\n    ) {\n      this.store[query.fetchMoreForQueryId].networkStatus =\n        NetworkStatus.fetchMore;\n    }\n  }\n\n  public markQueryResult(\n    queryId: string,\n    result: ExecutionResult,\n    fetchMoreForQueryId: string | undefined,\n  ) {\n    if (!this.store[queryId]) return;\n\n    this.store[queryId].networkError = null;\n    this.store[queryId].graphQLErrors =\n      result.errors && result.errors.length ? result.errors : [];\n    this.store[queryId].previousVariables = null;\n    this.store[queryId].networkStatus = NetworkStatus.ready;\n\n    // If we have a `fetchMoreForQueryId` then we need to update the network\n    // status for that query. See the branch for query initialization for more\n    // explanation about this process.\n    if (\n      typeof fetchMoreForQueryId === 'string' &&\n      this.store[fetchMoreForQueryId]\n    ) {\n      this.store[fetchMoreForQueryId].networkStatus = NetworkStatus.ready;\n    }\n  }\n\n  public markQueryError(\n    queryId: string,\n    error: Error,\n    fetchMoreForQueryId: string | undefined,\n  ) {\n    if (!this.store[queryId]) return;\n\n    this.store[queryId].networkError = error;\n    this.store[queryId].networkStatus = NetworkStatus.error;\n\n    // If we have a `fetchMoreForQueryId` then we need to update the network\n    // status for that query. See the branch for query initialization for more\n    // explanation about this process.\n    if (typeof fetchMoreForQueryId === 'string') {\n      this.markQueryResultClient(fetchMoreForQueryId, true);\n    }\n  }\n\n  public markQueryResultClient(queryId: string, complete: boolean) {\n    if (!this.store[queryId]) return;\n\n    this.store[queryId].networkError = null;\n    this.store[queryId].previousVariables = null;\n    this.store[queryId].networkStatus = complete\n      ? NetworkStatus.ready\n      : NetworkStatus.loading;\n  }\n\n  public stopQuery(queryId: string) {\n    delete this.store[queryId];\n  }\n\n  public reset(observableQueryIds: string[]) {\n    // keep only the queries with query ids that are associated with observables\n    this.store = Object.keys(this.store)\n      .filter(queryId => {\n        return observableQueryIds.indexOf(queryId) > -1;\n      })\n      .reduce(\n        (res, key) => {\n          // XXX set loading to true so listeners don't trigger unless they want results with partial data\n          res[key] = {\n            ...this.store[key],\n            networkStatus: NetworkStatus.loading,\n          };\n\n          return res;\n        },\n        {} as { [queryId: string]: QueryStoreValue },\n      );\n  }\n}\n","import { execute, ApolloLink, FetchResult } from 'apollo-link';\nimport { ExecutionResult, DocumentNode } from 'graphql';\nimport { print } from 'graphql/language/printer';\nimport { DedupLink as Deduplicator } from 'apollo-link-dedup';\nimport { Cache } from 'apollo-cache';\nimport {\n  assign,\n  getDefaultValues,\n  getMutationDefinition,\n  getOperationDefinition,\n  getOperationName,\n  getQueryDefinition,\n  isProduction,\n  hasDirectives,\n} from 'apollo-utilities';\n\nimport { QueryScheduler } from '../scheduler/scheduler';\n\nimport { isApolloError, ApolloError } from '../errors/ApolloError';\n\nimport { Observer, Subscription, Observable } from '../util/Observable';\n\nimport { QueryWithUpdater, DataStore } from '../data/store';\nimport { MutationStore } from '../data/mutations';\nimport { QueryStore, QueryStoreValue } from '../data/queries';\n\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n} from './watchQueryOptions';\nimport { ObservableQuery } from './ObservableQuery';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport {\n  QueryListener,\n  ApolloQueryResult,\n  FetchType,\n  OperationVariables,\n} from './types';\nimport { graphQLResultHasError } from 'apollo-utilities';\n\nexport interface QueryInfo {\n  listeners: QueryListener[];\n  invalidated: boolean;\n  newData: Cache.DiffResult<any> | null;\n  document: DocumentNode | null;\n  lastRequestId: number | null;\n  // A map going from queryId to an observer for a query issued by watchQuery. We use\n  // these to keep track of queries that are inflight and error on the observers associated\n  // with them in case of some destabalizing action (e.g. reset of the Apollo store).\n  observableQuery: ObservableQuery<any> | null;\n  subscriptions: Subscription[];\n  cancel?: (() => void);\n}\n\nconst defaultQueryInfo = {\n  listeners: [],\n  invalidated: false,\n  document: null,\n  newData: null,\n  lastRequestId: null,\n  observableQuery: null,\n  subscriptions: [],\n};\n\nexport interface QueryPromise {\n  resolve: (result: ApolloQueryResult<any>) => void;\n  reject: (error: Error) => void;\n}\n\nexport class QueryManager<TStore> {\n  public scheduler: QueryScheduler<TStore>;\n  public link: ApolloLink;\n  public mutationStore: MutationStore = new MutationStore();\n  public queryStore: QueryStore = new QueryStore();\n  public dataStore: DataStore<TStore>;\n\n  private deduplicator: ApolloLink;\n  private queryDeduplication: boolean;\n\n  private onBroadcast: () => void;\n\n  // let's not start at zero to avoid pain with bad checks\n  private idCounter = 1;\n\n  // XXX merge with ObservableQuery but that needs to be expanded to support mutations and\n  // subscriptions as well\n  private queries: Map<string, QueryInfo> = new Map();\n\n  // A map going from a requestId to a promise that has not yet been resolved. We use this to keep\n  // track of queries that are inflight and reject them in case some\n  // destabalizing action occurs (e.g. reset of the Apollo store).\n  private fetchQueryPromises: Map<string, QueryPromise> = new Map();\n\n  // A map going from the name of a query to an observer issued for it by watchQuery. This is\n  // generally used to refetches for refetchQueries and to update mutation results through\n  // updateQueries.\n  private queryIdsByName: { [queryName: string]: string[] } = {};\n\n  constructor({\n    link,\n    queryDeduplication = false,\n    store,\n    onBroadcast = () => undefined,\n    ssrMode = false,\n  }: {\n    link: ApolloLink;\n    queryDeduplication?: boolean;\n    store: DataStore<TStore>;\n    onBroadcast?: () => void;\n    ssrMode?: boolean;\n  }) {\n    this.link = link;\n    this.deduplicator = ApolloLink.from([new Deduplicator(), link]);\n    this.queryDeduplication = queryDeduplication;\n    this.dataStore = store;\n    this.onBroadcast = onBroadcast;\n\n    this.scheduler = new QueryScheduler({ queryManager: this, ssrMode });\n  }\n\n  public mutate<T>({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries: updateQueriesByName,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    errorPolicy = 'none',\n    fetchPolicy,\n    context = {},\n  }: MutationOptions): Promise<FetchResult<T>> {\n    if (!mutation) {\n      throw new Error(\n        'mutation option is required. You must specify your GraphQL document in the mutation option.',\n      );\n    }\n\n    if (fetchPolicy && fetchPolicy !== 'no-cache') {\n      throw new Error(\n        \"fetchPolicy for mutations currently only supports the 'no-cache' policy\",\n      );\n    }\n\n    const mutationId = this.generateQueryId();\n    const cache = this.dataStore.getCache();\n    (mutation = cache.transformDocument(mutation)),\n      (variables = assign(\n        {},\n        getDefaultValues(getMutationDefinition(mutation)),\n        variables,\n      ));\n    const mutationString = print(mutation);\n\n    this.setQuery(mutationId, () => ({ document: mutation }));\n\n    // Create a map of update queries by id to the query instead of by name.\n    const generateUpdateQueriesInfo: () => {\n      [queryId: string]: QueryWithUpdater;\n    } = () => {\n      const ret: { [queryId: string]: QueryWithUpdater } = {};\n\n      if (updateQueriesByName) {\n        Object.keys(updateQueriesByName).forEach(queryName =>\n          (this.queryIdsByName[queryName] || []).forEach(queryId => {\n            ret[queryId] = {\n              updater: updateQueriesByName[queryName],\n              query: this.queryStore.get(queryId),\n            };\n          }),\n        );\n      }\n\n      return ret;\n    };\n\n    this.mutationStore.initMutation(mutationId, mutationString, variables);\n\n    this.dataStore.markMutationInit({\n      mutationId,\n      document: mutation,\n      variables: variables || {},\n      updateQueries: generateUpdateQueriesInfo(),\n      update: updateWithProxyFn,\n      optimisticResponse,\n    });\n\n    this.broadcastQueries();\n\n    return new Promise((resolve, reject) => {\n      let storeResult: FetchResult<T> | null;\n      let error: ApolloError;\n\n      const operation = this.buildOperationForLink(mutation, variables, {\n        ...context,\n        optimisticResponse,\n      });\n\n      const completeMutation = async () => {\n        if (error) {\n          this.mutationStore.markMutationError(mutationId, error);\n        }\n\n        this.dataStore.markMutationComplete({\n          mutationId,\n          optimisticResponse,\n        });\n\n        this.broadcastQueries();\n\n        if (error) {\n          throw error;\n        }\n\n        // allow for conditional refetches\n        // XXX do we want to make this the only API one day?\n        if (typeof refetchQueries === 'function') {\n          refetchQueries = refetchQueries(storeResult as ExecutionResult);\n        }\n\n        const refetchQueryPromises: Promise<\n          ApolloQueryResult<any>[] | ApolloQueryResult<{}>\n        >[] = [];\n\n        for (const refetchQuery of refetchQueries) {\n          if (typeof refetchQuery === 'string') {\n            const promise = this.refetchQueryByName(refetchQuery);\n            if (promise) {\n              refetchQueryPromises.push(promise);\n            }\n            continue;\n          }\n\n          const queryOptions: QueryOptions = {\n            query: refetchQuery.query,\n            variables: refetchQuery.variables,\n            fetchPolicy: 'network-only',\n          };\n\n          if (refetchQuery.context) {\n            queryOptions.context = refetchQuery.context;\n          }\n\n          refetchQueryPromises.push(this.query(queryOptions));\n        }\n\n        if (awaitRefetchQueries) {\n          await Promise.all(refetchQueryPromises);\n        }\n\n        this.setQuery(mutationId, () => ({ document: undefined }));\n        if (\n          errorPolicy === 'ignore' &&\n          storeResult &&\n          graphQLResultHasError(storeResult)\n        ) {\n          delete storeResult.errors;\n        }\n\n        return storeResult as FetchResult<T>;\n      };\n\n      execute(this.link, operation).subscribe({\n        next: (result: ExecutionResult) => {\n          if (graphQLResultHasError(result) && errorPolicy === 'none') {\n            error = new ApolloError({\n              graphQLErrors: result.errors,\n            });\n            return;\n          }\n\n          this.mutationStore.markMutationResult(mutationId);\n\n          if (fetchPolicy !== 'no-cache') {\n            this.dataStore.markMutationResult({\n              mutationId,\n              result,\n              document: mutation,\n              variables: variables || {},\n              updateQueries: generateUpdateQueriesInfo(),\n              update: updateWithProxyFn,\n            });\n          }\n          storeResult = result as FetchResult<T>;\n        },\n\n        error: (err: Error) => {\n          this.mutationStore.markMutationError(mutationId, err);\n          this.dataStore.markMutationComplete({\n            mutationId,\n            optimisticResponse,\n          });\n          this.broadcastQueries();\n\n          this.setQuery(mutationId, () => ({ document: undefined }));\n          reject(\n            new ApolloError({\n              networkError: err,\n            }),\n          );\n        },\n\n        complete: () => completeMutation().then(resolve, reject),\n      });\n    });\n  }\n\n  public fetchQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    fetchType?: FetchType,\n    // This allows us to track if this is a query spawned by a `fetchMore`\n    // call for another query. We need this data to compute the `fetchMore`\n    // network status for the query this is fetching for.\n    fetchMoreForQueryId?: string,\n  ): Promise<FetchResult<T>> {\n    const {\n      variables = {},\n      metadata = null,\n      fetchPolicy = 'cache-first', // cache-first is the default fetch policy.\n    } = options;\n    const cache = this.dataStore.getCache();\n\n    const query = cache.transformDocument(options.query);\n\n    let storeResult: any;\n    let needToFetch: boolean =\n      fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';\n\n    // If this is not a force fetch, we want to diff the query against the\n    // store before we fetch it from the network interface.\n    // TODO we hit the cache even if the policy is network-first. This could be unnecessary if the network is up.\n    if (\n      fetchType !== FetchType.refetch &&\n      fetchPolicy !== 'network-only' &&\n      fetchPolicy !== 'no-cache'\n    ) {\n      const { complete, result } = this.dataStore.getCache().diff({\n        query,\n        variables,\n        returnPartialData: true,\n        optimistic: false,\n      });\n\n      // If we're in here, only fetch if we have missing fields\n      needToFetch = !complete || fetchPolicy === 'cache-and-network';\n      storeResult = result;\n    }\n\n    let shouldFetch =\n      needToFetch && fetchPolicy !== 'cache-only' && fetchPolicy !== 'standby';\n\n    // we need to check to see if this is an operation that uses the @live directive\n    if (hasDirectives(['live'], query)) shouldFetch = true;\n\n    const requestId = this.generateRequestId();\n\n    // set up a watcher to listen to cache updates\n    const cancel = this.updateQueryWatch(queryId, query, options);\n\n    // Initialize query in store with unique requestId\n    this.setQuery(queryId, () => ({\n      document: query,\n      lastRequestId: requestId,\n      invalidated: true,\n      cancel,\n    }));\n\n    this.invalidate(true, fetchMoreForQueryId);\n\n    this.queryStore.initQuery({\n      queryId,\n      document: query,\n      storePreviousVariables: shouldFetch,\n      variables,\n      isPoll: fetchType === FetchType.poll,\n      isRefetch: fetchType === FetchType.refetch,\n      metadata,\n      fetchMoreForQueryId,\n    });\n\n    this.broadcastQueries();\n\n    // If there is no part of the query we need to fetch from the server (or,\n    // fetchPolicy is cache-only), we just write the store result as the final result.\n    const shouldDispatchClientResult =\n      !shouldFetch || fetchPolicy === 'cache-and-network';\n\n    if (shouldDispatchClientResult) {\n      this.queryStore.markQueryResultClient(queryId, !shouldFetch);\n\n      this.invalidate(true, queryId, fetchMoreForQueryId);\n\n      this.broadcastQueries();\n    }\n\n    if (shouldFetch) {\n      const networkResult = this.fetchRequest({\n        requestId,\n        queryId,\n        document: query,\n        options,\n        fetchMoreForQueryId,\n      }).catch(error => {\n        // This is for the benefit of `refetch` promises, which currently don't get their errors\n        // through the store like watchQuery observers do\n        if (isApolloError(error)) {\n          throw error;\n        } else {\n          const { lastRequestId } = this.getQuery(queryId);\n          if (requestId >= (lastRequestId || 1)) {\n            this.queryStore.markQueryError(queryId, error, fetchMoreForQueryId);\n\n            this.invalidate(true, queryId, fetchMoreForQueryId);\n\n            this.broadcastQueries();\n          }\n\n          this.removeFetchQueryPromise(requestId);\n\n          throw new ApolloError({ networkError: error });\n        }\n      });\n\n      // we don't return the promise for cache-and-network since it is already\n      // returned below from the cache\n      if (fetchPolicy !== 'cache-and-network') {\n        return networkResult;\n      } else {\n        // however we need to catch the error so it isn't unhandled in case of\n        // network error\n        networkResult.catch(() => {});\n      }\n    }\n\n    // If we have no query to send to the server, we should return the result\n    // found within the store.\n    return Promise.resolve<ExecutionResult>({ data: storeResult });\n  }\n\n  // Returns a query listener that will update the given observer based on the\n  // results (or lack thereof) for a particular query.\n  public queryListenerForObserver<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    observer: Observer<ApolloQueryResult<T>>,\n  ): QueryListener {\n    let previouslyHadError: boolean = false;\n    return (\n      queryStoreValue: QueryStoreValue,\n      newData?: Cache.DiffResult<T>,\n    ) => {\n      // we're going to take a look at the data, so the query is no longer invalidated\n      this.invalidate(false, queryId);\n\n      // The query store value can be undefined in the event of a store\n      // reset.\n      if (!queryStoreValue) return;\n\n      const { observableQuery } = this.getQuery(queryId);\n\n      const fetchPolicy = observableQuery\n        ? observableQuery.options.fetchPolicy\n        : options.fetchPolicy;\n\n      // don't watch the store for queries on standby\n      if (fetchPolicy === 'standby') return;\n\n      const errorPolicy = observableQuery\n        ? observableQuery.options.errorPolicy\n        : options.errorPolicy;\n\n      const lastResult = observableQuery\n        ? observableQuery.getLastResult()\n        : null;\n\n      const lastError = observableQuery ? observableQuery.getLastError() : null;\n\n      let shouldNotifyIfLoading =\n        (!newData && queryStoreValue.previousVariables != null) ||\n        fetchPolicy === 'cache-only' ||\n        fetchPolicy === 'cache-and-network';\n\n      // if this caused by a cache broadcast but the query is still in flight\n      // don't notify the observer\n      // if (\n      //   isCacheBroadcast &&\n      //   isNetworkRequestInFlight(queryStoreValue.networkStatus)\n      // ) {\n      //   shouldNotifyIfLoading = false;\n      // }\n\n      const networkStatusChanged = Boolean(\n        lastResult &&\n          queryStoreValue.networkStatus !== lastResult.networkStatus,\n      );\n\n      const errorStatusChanged =\n        errorPolicy &&\n        (lastError && lastError.graphQLErrors) !==\n          queryStoreValue.graphQLErrors &&\n        errorPolicy !== 'none';\n\n      if (\n        !isNetworkRequestInFlight(queryStoreValue.networkStatus) ||\n        (networkStatusChanged && options.notifyOnNetworkStatusChange) ||\n        shouldNotifyIfLoading\n      ) {\n        // If we have either a GraphQL error or a network error, we create\n        // an error and tell the observer about it.\n        if (\n          ((!errorPolicy || errorPolicy === 'none') &&\n            queryStoreValue.graphQLErrors &&\n            queryStoreValue.graphQLErrors.length > 0) ||\n          queryStoreValue.networkError\n        ) {\n          const apolloError = new ApolloError({\n            graphQLErrors: queryStoreValue.graphQLErrors,\n            networkError: queryStoreValue.networkError,\n          });\n          previouslyHadError = true;\n          if (observer.error) {\n            try {\n              observer.error(apolloError);\n            } catch (e) {\n              // Throw error outside this control flow to avoid breaking Apollo's state\n              setTimeout(() => {\n                throw e;\n              }, 0);\n            }\n          } else {\n            // Throw error outside this control flow to avoid breaking Apollo's state\n            setTimeout(() => {\n              throw apolloError;\n            }, 0);\n            if (!isProduction()) {\n              /* tslint:disable-next-line */\n              console.info(\n                'An unhandled error was thrown because no error handler is registered ' +\n                  'for the query ' +\n                  print(queryStoreValue.document),\n              );\n            }\n          }\n          return;\n        }\n\n        try {\n          let data: any;\n          let isMissing: boolean;\n\n          if (newData) {\n            // As long as we're using the cache, clear out the latest\n            // `newData`, since it will now become the current data. We need\n            // to keep the `newData` stored with the query when using\n            // `no-cache` since `getCurrentQueryResult` attemps to pull from\n            // `newData` first, following by trying the cache (which won't\n            // find a hit for `no-cache`).\n            if (fetchPolicy !== 'no-cache') {\n              this.setQuery(queryId, () => ({ newData: null }));\n            }\n\n            data = newData.result;\n            isMissing = !newData.complete || false;\n          } else {\n            if (lastResult && lastResult.data && !errorStatusChanged) {\n              data = lastResult.data;\n              isMissing = false;\n            } else {\n              const { document } = this.getQuery(queryId);\n              const readResult = this.dataStore.getCache().diff({\n                query: document as DocumentNode,\n                variables:\n                  queryStoreValue.previousVariables ||\n                  queryStoreValue.variables,\n                optimistic: true,\n              });\n\n              data = readResult.result;\n              isMissing = !readResult.complete;\n            }\n          }\n\n          let resultFromStore: ApolloQueryResult<T>;\n\n          // If there is some data missing and the user has told us that they\n          // do not tolerate partial data then we want to return the previous\n          // result and mark it as stale.\n          if (isMissing && fetchPolicy !== 'cache-only') {\n            resultFromStore = {\n              data: lastResult && lastResult.data,\n              loading: isNetworkRequestInFlight(queryStoreValue.networkStatus),\n              networkStatus: queryStoreValue.networkStatus,\n              stale: true,\n            };\n          } else {\n            resultFromStore = {\n              data,\n              loading: isNetworkRequestInFlight(queryStoreValue.networkStatus),\n              networkStatus: queryStoreValue.networkStatus,\n              stale: false,\n            };\n          }\n\n          // if the query wants updates on errors we need to add it to the result\n          if (\n            errorPolicy === 'all' &&\n            queryStoreValue.graphQLErrors &&\n            queryStoreValue.graphQLErrors.length > 0\n          ) {\n            resultFromStore.errors = queryStoreValue.graphQLErrors;\n          }\n\n          if (observer.next) {\n            const isDifferentResult = !(\n              lastResult &&\n              resultFromStore &&\n              lastResult.networkStatus === resultFromStore.networkStatus &&\n              lastResult.stale === resultFromStore.stale &&\n              // We can do a strict equality check here because we include a `previousResult`\n              // with `readQueryFromStore`. So if the results are the same they will be\n              // referentially equal.\n              lastResult.data === resultFromStore.data\n            );\n\n            if (isDifferentResult || previouslyHadError) {\n              try {\n                observer.next(resultFromStore);\n              } catch (e) {\n                // Throw error outside this control flow to avoid breaking Apollo's state\n                setTimeout(() => {\n                  throw e;\n                }, 0);\n              }\n            }\n          }\n          previouslyHadError = false;\n        } catch (error) {\n          previouslyHadError = true;\n          if (observer.error)\n            observer.error(new ApolloError({ networkError: error }));\n          return;\n        }\n      }\n    };\n  }\n\n  // The shouldSubscribe option is a temporary fix that tells us whether watchQuery was called\n  // directly (i.e. through ApolloClient) or through the query method within QueryManager.\n  // Currently, the query method uses watchQuery in order to handle non-network errors correctly\n  // but we don't want to keep track observables issued for the query method since those aren't\n  // supposed to be refetched in the event of a store reset. Once we unify error handling for\n  // network errors and non-network errors, the shouldSubscribe option will go away.\n\n  public watchQuery<T>(\n    options: WatchQueryOptions,\n    shouldSubscribe = true,\n  ): ObservableQuery<T> {\n    if (options.fetchPolicy === 'standby') {\n      throw new Error(\n        'client.watchQuery cannot be called with fetchPolicy set to \"standby\"',\n      );\n    }\n\n    // get errors synchronously\n    const queryDefinition = getQueryDefinition(options.query);\n\n    // assign variable default values if supplied\n    if (\n      queryDefinition.variableDefinitions &&\n      queryDefinition.variableDefinitions.length\n    ) {\n      const defaultValues = getDefaultValues(queryDefinition);\n\n      options.variables = assign({}, defaultValues, options.variables);\n    }\n\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    let transformedOptions = { ...options } as WatchQueryOptions;\n\n    return new ObservableQuery<T>({\n      scheduler: this.scheduler,\n      options: transformedOptions,\n      shouldSubscribe: shouldSubscribe,\n    });\n  }\n\n  public query<T>(options: QueryOptions): Promise<ApolloQueryResult<T>> {\n    if (!options.query) {\n      throw new Error(\n        'query option is required. You must specify your GraphQL document ' +\n          'in the query option.',\n      );\n    }\n\n    if (options.query.kind !== 'Document') {\n      throw new Error('You must wrap the query string in a \"gql\" tag.');\n    }\n\n    if ((options as any).returnPartialData) {\n      throw new Error('returnPartialData option only supported on watchQuery.');\n    }\n\n    if ((options as any).pollInterval) {\n      throw new Error('pollInterval option only supported on watchQuery.');\n    }\n\n    const requestId = this.idCounter;\n\n    return new Promise<ApolloQueryResult<T>>((resolve, reject) => {\n      this.addFetchQueryPromise<T>(requestId, resolve, reject);\n\n      return this.watchQuery<T>(options, false)\n        .result()\n        .then(result => {\n          this.removeFetchQueryPromise(requestId);\n          resolve(result);\n        })\n        .catch(error => {\n          this.removeFetchQueryPromise(requestId);\n          reject(error);\n        });\n    });\n  }\n\n  public generateQueryId() {\n    const queryId = this.idCounter.toString();\n    this.idCounter++;\n    return queryId;\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.queryStore.stopQuery(queryId);\n    this.invalidate(true, queryId);\n    this.broadcastQueries();\n  }\n\n  public addQueryListener(queryId: string, listener: QueryListener) {\n    this.setQuery(queryId, ({ listeners = [] }) => ({\n      listeners: listeners.concat([listener]),\n      invalidate: false,\n    }));\n  }\n\n  public updateQueryWatch(\n    queryId: string,\n    document: DocumentNode,\n    options: WatchQueryOptions,\n  ) {\n    const { cancel } = this.getQuery(queryId);\n    if (cancel) cancel();\n    const previousResult = () => {\n      let previousResult = null;\n      const { observableQuery } = this.getQuery(queryId);\n      if (observableQuery) {\n        const lastResult = observableQuery.getLastResult();\n        if (lastResult) {\n          previousResult = lastResult.data;\n        }\n      }\n\n      return previousResult;\n    };\n    return this.dataStore.getCache().watch({\n      query: document as DocumentNode,\n      variables: options.variables,\n      optimistic: true,\n      previousResult,\n      callback: (newData: ApolloQueryResult<any>) => {\n        this.setQuery(queryId, () => ({ invalidated: true, newData }));\n      },\n    });\n  }\n\n  // Adds a promise to this.fetchQueryPromises for a given request ID.\n  public addFetchQueryPromise<T>(\n    requestId: number,\n    resolve: (result: ApolloQueryResult<T>) => void,\n    reject: (error: Error) => void,\n  ) {\n    this.fetchQueryPromises.set(requestId.toString(), {\n      resolve,\n      reject,\n    });\n  }\n\n  // Removes the promise in this.fetchQueryPromises for a particular request ID.\n  public removeFetchQueryPromise(requestId: number) {\n    this.fetchQueryPromises.delete(requestId.toString());\n  }\n\n  // Adds an ObservableQuery to this.observableQueries and to this.observableQueriesByName.\n  public addObservableQuery<T>(\n    queryId: string,\n    observableQuery: ObservableQuery<T>,\n  ) {\n    this.setQuery(queryId, () => ({ observableQuery }));\n\n    // Insert the ObservableQuery into this.observableQueriesByName if the query has a name\n    const queryDef = getQueryDefinition(observableQuery.options.query);\n    if (queryDef.name && queryDef.name.value) {\n      const queryName = queryDef.name.value;\n\n      // XXX we may we want to warn the user about query name conflicts in the future\n      this.queryIdsByName[queryName] = this.queryIdsByName[queryName] || [];\n      this.queryIdsByName[queryName].push(observableQuery.queryId);\n    }\n  }\n\n  public removeObservableQuery(queryId: string) {\n    const { observableQuery, cancel } = this.getQuery(queryId);\n    if (cancel) cancel();\n    if (!observableQuery) return;\n\n    const definition = getQueryDefinition(observableQuery.options.query);\n    const queryName = definition.name ? definition.name.value : null;\n    this.setQuery(queryId, () => ({ observableQuery: null }));\n    if (queryName) {\n      this.queryIdsByName[queryName] = this.queryIdsByName[queryName].filter(\n        val => {\n          return !(observableQuery.queryId === val);\n        },\n      );\n    }\n  }\n\n  public clearStore(): Promise<void> {\n    // Before we have sent the reset action to the store,\n    // we can no longer rely on the results returned by in-flight\n    // requests since these may depend on values that previously existed\n    // in the data portion of the store. So, we cancel the promises and observers\n    // that we have issued so far and not yet resolved (in the case of\n    // queries).\n    this.fetchQueryPromises.forEach(({ reject }) => {\n      reject(\n        new Error(\n          'Store reset while query was in flight(not completed in link chain)',\n        ),\n      );\n    });\n\n    const resetIds: string[] = [];\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (observableQuery) resetIds.push(queryId);\n    });\n\n    this.queryStore.reset(resetIds);\n    this.mutationStore.reset();\n\n    // begin removing data from the store\n    const reset = this.dataStore.reset();\n    return reset;\n  }\n\n  public resetStore(): Promise<ApolloQueryResult<any>[]> {\n    // Similarly, we have to have to refetch each of the queries currently being\n    // observed. We refetch instead of error'ing on these since the assumption is that\n    // resetting the store doesn't eliminate the need for the queries currently being\n    // watched. If there is an existing query in flight when the store is reset,\n    // the promise for it will be rejected and its results will not be written to the\n    // store.\n    return this.clearStore().then(() => {\n      return this.reFetchObservableQueries();\n    });\n  }\n\n  public reFetchObservableQueries(\n    includeStandby?: boolean,\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<\n      ApolloQueryResult<any>\n    >[] = this.getObservableQueryPromises(includeStandby);\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public startQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    listener: QueryListener,\n  ) {\n    this.addQueryListener(queryId, listener);\n\n    this.fetchQuery<T>(queryId, options)\n      // `fetchQuery` returns a Promise. In case of a failure it should be caucht or else the\n      // console will show an `Uncaught (in promise)` message. Ignore the error for now.\n      .catch(() => undefined);\n\n    return queryId;\n  }\n\n  public startGraphQLSubscription(\n    options: SubscriptionOptions,\n  ): Observable<any> {\n    const { query } = options;\n    const isCacheEnabled = !(\n      options.fetchPolicy && options.fetchPolicy === 'no-cache'\n    );\n    const cache = this.dataStore.getCache();\n    let transformedDoc = cache.transformDocument(query);\n\n    const variables = assign(\n      {},\n      getDefaultValues(getOperationDefinition(query)),\n      options.variables,\n    );\n\n    let sub: Subscription;\n    let observers: Observer<any>[] = [];\n\n    return new Observable(observer => {\n      observers.push(observer);\n\n      // If this is the first observer, actually initiate the network\n      // subscription.\n      if (observers.length === 1) {\n        const handler = {\n          next: (result: FetchResult) => {\n            if (isCacheEnabled) {\n              this.dataStore.markSubscriptionResult(\n                result,\n                transformedDoc,\n                variables,\n              );\n              this.broadcastQueries();\n            }\n\n            observers.forEach(obs => {\n              // If an error exists and a `error` handler has been defined on\n              // the observer, call that `error` handler and make sure the\n              // `next` handler is skipped. If no `error` handler exists, we're\n              // still passing any errors that might occur into the `next`\n              // handler, to give that handler a chance to deal with the\n              // error (we're doing this for backwards compatibilty).\n              if (graphQLResultHasError(result) && obs.error) {\n                obs.error(\n                  new ApolloError({\n                    graphQLErrors: result.errors,\n                  }),\n                );\n              } else if (obs.next) {\n                obs.next(result);\n              }\n            });\n          },\n          error: (error: Error) => {\n            observers.forEach(obs => {\n              if (obs.error) {\n                obs.error(error);\n              }\n            });\n          },\n        };\n\n        // TODO: Should subscriptions also accept a `context` option to pass\n        // through to links?\n        const operation = this.buildOperationForLink(transformedDoc, variables);\n        sub = execute(this.link, operation).subscribe(handler);\n      }\n\n      return () => {\n        observers = observers.filter(obs => obs !== observer);\n\n        // If we removed the last observer, tear down the network subscription\n        if (observers.length === 0 && sub) {\n          sub.unsubscribe();\n        }\n      };\n    });\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryInStore(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    const { subscriptions } = this.getQuery(queryId);\n    // teardown all links\n    subscriptions.forEach(x => x.unsubscribe());\n    this.queries.delete(queryId);\n  }\n\n  public getCurrentQueryResult<T>(\n    observableQuery: ObservableQuery<T>,\n    optimistic: boolean = true,\n  ) {\n    const { variables, query } = observableQuery.options;\n    const lastResult = observableQuery.getLastResult();\n    const { newData } = this.getQuery(observableQuery.queryId);\n    // XXX test this\n    if (newData) {\n      return { data: newData.result, partial: false };\n    } else {\n      try {\n        // the query is brand new, so we read from the store to see if anything is there\n        const data = this.dataStore.getCache().read({\n          query,\n          variables,\n          previousResult: lastResult ? lastResult.data : undefined,\n          optimistic,\n        });\n\n        return { data, partial: false };\n      } catch (e) {\n        return { data: {}, partial: true };\n      }\n    }\n  }\n\n  public getQueryWithPreviousResult<T>(\n    queryIdOrObservable: string | ObservableQuery<T>,\n  ): {\n    previousResult: any;\n    variables: OperationVariables | undefined;\n    document: DocumentNode;\n  } {\n    let observableQuery: ObservableQuery<T>;\n    if (typeof queryIdOrObservable === 'string') {\n      const { observableQuery: foundObserveableQuery } = this.getQuery(\n        queryIdOrObservable,\n      );\n      if (!foundObserveableQuery) {\n        throw new Error(\n          `ObservableQuery with this id doesn't exist: ${queryIdOrObservable}`,\n        );\n      }\n      observableQuery = foundObserveableQuery;\n    } else {\n      observableQuery = queryIdOrObservable;\n    }\n\n    const { variables, query } = observableQuery.options;\n\n    const { data } = this.getCurrentQueryResult(observableQuery, false);\n\n    return {\n      previousResult: data,\n      variables,\n      document: query,\n    };\n  }\n\n  public broadcastQueries() {\n    this.onBroadcast();\n    this.queries.forEach((info, id) => {\n      if (!info.invalidated || !info.listeners) return;\n      info.listeners\n        // it's possible for the listener to be undefined if the query is being stopped\n        // See here for more detail: https://github.com/apollostack/apollo-client/issues/231\n        .filter((x: QueryListener) => !!x)\n        .forEach((listener: QueryListener) => {\n          listener(this.queryStore.get(id), info.newData);\n        });\n    });\n  }\n\n  private getObservableQueryPromises(\n    includeStandby?: boolean,\n  ): Promise<ApolloQueryResult<any>>[] {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (!observableQuery) return;\n      const fetchPolicy = observableQuery.options.fetchPolicy;\n\n      observableQuery.resetLastResults();\n      if (\n        fetchPolicy !== 'cache-only' &&\n        (includeStandby || fetchPolicy !== 'standby')\n      ) {\n        observableQueryPromises.push(observableQuery.refetch());\n      }\n\n      this.setQuery(queryId, () => ({ newData: null }));\n      this.invalidate(true, queryId);\n    });\n\n    return observableQueryPromises;\n  }\n\n  // Takes a request id, query id, a query document and information associated with the query\n  // and send it to the network interface. Returns\n  // a promise for the result associated with that request.\n  private fetchRequest<T>({\n    requestId,\n    queryId,\n    document,\n    options,\n    fetchMoreForQueryId,\n  }: {\n    requestId: number;\n    queryId: string;\n    document: DocumentNode;\n    options: WatchQueryOptions;\n    fetchMoreForQueryId?: string;\n  }): Promise<ExecutionResult> {\n    const { variables, context, errorPolicy = 'none', fetchPolicy } = options;\n    const operation = this.buildOperationForLink(document, variables, {\n      ...context,\n      // TODO: Should this be included for all entry points via\n      // buildOperationForLink?\n      forceFetch: !this.queryDeduplication,\n    });\n\n    let resultFromStore: any;\n    let errorsFromStore: any;\n\n    return new Promise<ApolloQueryResult<T>>((resolve, reject) => {\n      this.addFetchQueryPromise<T>(requestId, resolve, reject);\n      const subscription = execute(this.deduplicator, operation).subscribe({\n        next: (result: ExecutionResult) => {\n          // default the lastRequestId to 1\n          const { lastRequestId } = this.getQuery(queryId);\n          if (requestId >= (lastRequestId || 1)) {\n            if (fetchPolicy !== 'no-cache') {\n              try {\n                this.dataStore.markQueryResult(\n                  result,\n                  document,\n                  variables,\n                  fetchMoreForQueryId,\n                  errorPolicy === 'ignore' || errorPolicy === 'all',\n                );\n              } catch (e) {\n                reject(e);\n                return;\n              }\n            } else {\n              this.setQuery(queryId, () => ({\n                newData: { result: result.data, complete: true },\n              }));\n            }\n\n            this.queryStore.markQueryResult(\n              queryId,\n              result,\n              fetchMoreForQueryId,\n            );\n\n            this.invalidate(true, queryId, fetchMoreForQueryId);\n\n            this.broadcastQueries();\n          }\n\n          if (result.errors && errorPolicy === 'none') {\n            reject(\n              new ApolloError({\n                graphQLErrors: result.errors,\n              }),\n            );\n            return;\n          } else if (errorPolicy === 'all') {\n            errorsFromStore = result.errors;\n          }\n\n          if (fetchMoreForQueryId || fetchPolicy === 'no-cache') {\n            // We don't write fetchMore results to the store because this would overwrite\n            // the original result in case an @connection directive is used.\n            resultFromStore = result.data;\n          } else {\n            try {\n              // ensure result is combined with data already in store\n              resultFromStore = this.dataStore.getCache().read({\n                variables,\n                query: document,\n                optimistic: false,\n              });\n              // this will throw an error if there are missing fields in\n              // the results which can happen with errors from the server.\n              // tslint:disable-next-line\n            } catch (e) {}\n          }\n        },\n        error: (error: ApolloError) => {\n          this.removeFetchQueryPromise(requestId);\n          this.setQuery(queryId, ({ subscriptions }) => ({\n            subscriptions: subscriptions.filter(x => x !== subscription),\n          }));\n\n          reject(error);\n        },\n        complete: () => {\n          this.removeFetchQueryPromise(requestId);\n          this.setQuery(queryId, ({ subscriptions }) => ({\n            subscriptions: subscriptions.filter(x => x !== subscription),\n          }));\n\n          resolve({\n            data: resultFromStore,\n            errors: errorsFromStore,\n            loading: false,\n            networkStatus: NetworkStatus.ready,\n            stale: false,\n          });\n        },\n      });\n\n      this.setQuery(queryId, ({ subscriptions }) => ({\n        subscriptions: subscriptions.concat([subscription]),\n      }));\n    });\n  }\n\n  // Refetches a query given that query's name. Refetches\n  // all ObservableQuery instances associated with the query name.\n  private refetchQueryByName(queryName: string) {\n    const refetchedQueries = this.queryIdsByName[queryName];\n    // early return if the query named does not exist (not yet fetched)\n    // this used to warn but it may be inteneded behavoir to try and refetch\n    // un called queries because they could be on different routes\n    if (refetchedQueries === undefined) return;\n    return Promise.all(\n      refetchedQueries\n        .map(id => this.getQuery(id).observableQuery)\n        .filter(x => !!x)\n        .map((x: ObservableQuery<any>) => x.refetch()),\n    );\n  }\n\n  private generateRequestId() {\n    const requestId = this.idCounter;\n    this.idCounter++;\n    return requestId;\n  }\n\n  private getQuery(queryId: string) {\n    return this.queries.get(queryId) || { ...defaultQueryInfo };\n  }\n\n  private setQuery(queryId: string, updater: (prev: QueryInfo) => any) {\n    const prev = this.getQuery(queryId);\n    const newInfo = { ...prev, ...updater(prev) };\n    this.queries.set(queryId, newInfo);\n  }\n\n  private invalidate(\n    invalidated: boolean,\n    queryId?: string,\n    fetchMoreForQueryId?: string,\n  ) {\n    if (queryId) this.setQuery(queryId, () => ({ invalidated }));\n\n    if (fetchMoreForQueryId) {\n      this.setQuery(fetchMoreForQueryId, () => ({ invalidated }));\n    }\n  }\n\n  private buildOperationForLink(\n    document: DocumentNode,\n    variables: any,\n    extraContext?: any,\n  ) {\n    const cache = this.dataStore.getCache();\n\n    return {\n      query: cache.transformForLink\n        ? cache.transformForLink(document)\n        : document,\n      variables,\n      operationName: getOperationName(document) || undefined,\n      context: {\n        ...extraContext,\n        cache,\n        // getting an entry's cache key is useful for cacheResolvers & state-link\n        getCacheKey: (obj: { __typename: string; id: string | number }) => {\n          if ((cache as any).config) {\n            // on the link, we just want the id string, not the full id value from toIdValue\n            return (cache as any).config.dataIdFromObject(obj);\n          } else {\n            throw new Error(\n              'To use context.getCacheKey, you need to use a cache that has a configurable dataIdFromObject, like apollo-cache-inmemory.',\n            );\n          }\n        },\n      },\n    };\n  }\n}\n","import { ExecutionResult, DocumentNode } from 'graphql';\nimport { ApolloCache, Cache, DataProxy } from 'apollo-cache';\n\nimport { QueryStoreValue } from '../data/queries';\nimport {\n  getOperationName,\n  tryFunctionOrLogError,\n  graphQLResultHasError,\n} from 'apollo-utilities';\nimport { MutationQueryReducer } from '../core/types';\n\nexport type QueryWithUpdater = {\n  updater: MutationQueryReducer<Object>;\n  query: QueryStoreValue;\n};\n\nexport interface DataWrite {\n  rootId: string;\n  result: any;\n  document: DocumentNode;\n  operationName: string | null;\n  variables: Object;\n}\n\nexport class DataStore<TSerialized> {\n  private cache: ApolloCache<TSerialized>;\n\n  constructor(initialCache: ApolloCache<TSerialized>) {\n    this.cache = initialCache;\n  }\n\n  public getCache(): ApolloCache<TSerialized> {\n    return this.cache;\n  }\n\n  public markQueryResult(\n    result: ExecutionResult,\n    document: DocumentNode,\n    variables: any,\n    fetchMoreForQueryId: string | undefined,\n    ignoreErrors: boolean = false,\n  ) {\n    let writeWithErrors = !graphQLResultHasError(result);\n    if (ignoreErrors && graphQLResultHasError(result) && result.data) {\n      writeWithErrors = true;\n    }\n    if (!fetchMoreForQueryId && writeWithErrors) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_QUERY',\n        query: document,\n        variables: variables,\n      });\n    }\n  }\n\n  public markSubscriptionResult(\n    result: ExecutionResult,\n    document: DocumentNode,\n    variables: any,\n  ) {\n    // the subscription interface should handle not sending us results we no longer subscribe to.\n    // XXX I don't think we ever send in an object with errors, but we might in the future...\n    if (!graphQLResultHasError(result)) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_SUBSCRIPTION',\n        query: document,\n        variables: variables,\n      });\n    }\n  }\n\n  public markMutationInit(mutation: {\n    mutationId: string;\n    document: DocumentNode;\n    variables: any;\n    updateQueries: { [queryId: string]: QueryWithUpdater };\n    update: ((proxy: DataProxy, mutationResult: Object) => void) | undefined;\n    optimisticResponse: Object | Function | undefined;\n  }) {\n    if (mutation.optimisticResponse) {\n      let optimistic: Object;\n      if (typeof mutation.optimisticResponse === 'function') {\n        optimistic = mutation.optimisticResponse(mutation.variables);\n      } else {\n        optimistic = mutation.optimisticResponse;\n      }\n\n      const changeFn = () => {\n        this.markMutationResult({\n          mutationId: mutation.mutationId,\n          result: { data: optimistic },\n          document: mutation.document,\n          variables: mutation.variables,\n          updateQueries: mutation.updateQueries,\n          update: mutation.update,\n        });\n      };\n\n      this.cache.recordOptimisticTransaction(c => {\n        const orig = this.cache;\n        this.cache = c;\n\n        try {\n          changeFn();\n        } finally {\n          this.cache = orig;\n        }\n      }, mutation.mutationId);\n    }\n  }\n\n  public markMutationResult(mutation: {\n    mutationId: string;\n    result: ExecutionResult;\n    document: DocumentNode;\n    variables: any;\n    updateQueries: { [queryId: string]: QueryWithUpdater };\n    update: ((proxy: DataProxy, mutationResult: Object) => void) | undefined;\n  }) {\n    // Incorporate the result from this mutation into the store\n    if (!graphQLResultHasError(mutation.result)) {\n      const cacheWrites: Cache.WriteOptions[] = [];\n      cacheWrites.push({\n        result: mutation.result.data,\n        dataId: 'ROOT_MUTATION',\n        query: mutation.document,\n        variables: mutation.variables,\n      });\n\n      if (mutation.updateQueries) {\n        Object.keys(mutation.updateQueries)\n          .filter(id => mutation.updateQueries[id])\n          .forEach(queryId => {\n            const { query, updater } = mutation.updateQueries[queryId];\n            // Read the current query result from the store.\n            const { result: currentQueryResult, complete } = this.cache.diff({\n              query: query.document,\n              variables: query.variables,\n              returnPartialData: true,\n              optimistic: false,\n            });\n\n            if (!complete) {\n              return;\n            }\n\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = tryFunctionOrLogError(() =>\n              updater(currentQueryResult, {\n                mutationResult: mutation.result,\n                queryName: getOperationName(query.document) || undefined,\n                queryVariables: query.variables,\n              }),\n            );\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: query.document,\n                variables: query.variables,\n              });\n            }\n          });\n      }\n\n      this.cache.performTransaction(c => {\n        cacheWrites.forEach(write => c.write(write));\n      });\n\n      // If the mutation has some writes associated with it then we need to\n      // apply those writes to the store by running this reducer again with a\n      // write action.\n      const update = mutation.update;\n      if (update) {\n        this.cache.performTransaction(c => {\n          tryFunctionOrLogError(() => update(c, mutation.result));\n        });\n      }\n    }\n  }\n\n  public markMutationComplete({\n    mutationId,\n    optimisticResponse,\n  }: {\n    mutationId: string;\n    optimisticResponse?: any;\n  }) {\n    if (!optimisticResponse) return;\n    this.cache.removeOptimistic(mutationId);\n  }\n\n  public markUpdateQueryResult(\n    document: DocumentNode,\n    variables: any,\n    newResult: any,\n  ) {\n    this.cache.write({\n      result: newResult,\n      dataId: 'ROOT_QUERY',\n      variables,\n      query: document,\n    });\n  }\n\n  public reset(): Promise<void> {\n    return this.cache.reset();\n  }\n}\n","export const version = \"2.4.2\"","import {\n  ApolloLink,\n  Operation,\n  NextLink,\n  FetchResult,\n  GraphQLRequest,\n  execute,\n} from 'apollo-link';\nimport { ExecutionResult } from 'graphql';\nimport { ApolloCache, DataProxy } from 'apollo-cache';\nimport {\n  isProduction,\n  removeConnectionDirectiveFromDocument,\n} from 'apollo-utilities';\n\nimport { QueryManager } from './core/QueryManager';\nimport { ApolloQueryResult, OperationVariables } from './core/types';\nimport { ObservableQuery } from './core/ObservableQuery';\n\nimport { Observable } from './util/Observable';\n\nimport {\n  QueryBaseOptions,\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  ModifiableWatchQueryOptions,\n  MutationBaseOptions,\n} from './core/watchQueryOptions';\n\nimport { DataStore } from './data/store';\n\nimport { version } from './version';\n\nexport interface DefaultOptions {\n  watchQuery?: ModifiableWatchQueryOptions;\n  query?: QueryBaseOptions;\n  mutate?: MutationBaseOptions;\n}\n\nlet hasSuggestedDevtools = false;\n\nexport type ApolloClientOptions<TCacheShape> = {\n  link: ApolloLink;\n  cache: ApolloCache<TCacheShape>;\n  ssrMode?: boolean;\n  ssrForceFetchDelay?: number;\n  connectToDevTools?: boolean;\n  queryDeduplication?: boolean;\n  defaultOptions?: DefaultOptions;\n};\n\nconst supportedDirectives = new ApolloLink(\n  (operation: Operation, forward: NextLink) => {\n    operation.query = removeConnectionDirectiveFromDocument(operation.query);\n    return forward(operation);\n  },\n);\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over a {@link NetworkInterface} instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through {@link Observable} instances.\n */\nexport default class ApolloClient<TCacheShape> implements DataProxy {\n  public link: ApolloLink;\n  public store: DataStore<TCacheShape>;\n  public cache: ApolloCache<TCacheShape>;\n  public queryManager: QueryManager<TCacheShape> | undefined;\n  public disableNetworkFetches: boolean;\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: DefaultOptions = {};\n\n  private devToolsHookCb: Function;\n  private proxy: ApolloCache<TCacheShape> | undefined;\n  private ssrMode: boolean;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n\n  /**\n   * Constructs an instance of {@link ApolloClient}.\n   *\n   * @param link The {@link ApolloLink} over which GraphQL documents will be resolved into a response.\n   *\n   * @param cache The initial cache to use in the data store.\n   *\n   * @param ssrMode Determines whether this is being run in Server Side Rendering (SSR) mode.\n   *\n   * @param ssrForceFetchDelay Determines the time interval before we force fetch queries for a\n   * server side render.\n   *\n   * @param queryDeduplication If set to false, a query will still be sent to the server even if a query\n   * with identical parameters (query, variables, operationName) is already in flight.\n   *\n   */\n\n  constructor(options: ApolloClientOptions<TCacheShape>) {\n    const {\n      link,\n      cache,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      connectToDevTools,\n      queryDeduplication = true,\n      defaultOptions,\n    } = options;\n\n    if (!link || !cache) {\n      throw new Error(`\n        In order to initialize Apollo Client, you must specify link & cache properties on the config object.\n        This is part of the required upgrade when migrating from Apollo Client 1.0 to Apollo Client 2.0.\n        For more information, please visit:\n          https://www.apollographql.com/docs/react/basics/setup.html\n        to help you get started.\n      `);\n    }\n\n    // remove apollo-client supported directives\n    this.link = supportedDirectives.concat(link);\n    this.cache = cache;\n    this.store = new DataStore(cache);\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.ssrMode = ssrMode;\n    this.defaultOptions = defaultOptions || {};\n\n    if (ssrForceFetchDelay) {\n      setTimeout(\n        () => (this.disableNetworkFetches = false),\n        ssrForceFetchDelay,\n      );\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    // Attach the client instance to window to let us be found by chrome devtools, but only in\n    // development mode\n    const defaultConnectToDevTools =\n      !isProduction() &&\n      typeof window !== 'undefined' &&\n      !(window as any).__APOLLO_CLIENT__;\n\n    if (\n      typeof connectToDevTools === 'undefined'\n        ? defaultConnectToDevTools\n        : connectToDevTools && typeof window !== 'undefined'\n    ) {\n      (window as any).__APOLLO_CLIENT__ = this;\n    }\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && !isProduction()) {\n      hasSuggestedDevtools = true;\n      if (\n        typeof window !== 'undefined' &&\n        window.document &&\n        window.top === window.self\n      ) {\n        // First check if devtools is not installed\n        if (\n          typeof (window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__ === 'undefined'\n        ) {\n          // Only for Chrome\n          if (\n            window.navigator &&\n            window.navigator.userAgent.indexOf('Chrome') > -1\n          ) {\n            // tslint:disable-next-line\n            console.debug(\n              'Download the Apollo DevTools ' +\n                'for a better development experience: ' +\n                'https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm',\n            );\n          }\n        }\n      }\n    }\n    this.version = version;\n  }\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an {@link ObservableQuery}. We can subscribe to this {@link ObservableQuery} and\n   * receive updated results through a GraphQL observer when the cache store changes.\n   * <p /><p />\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   * <p /><p />\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifer, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   * <p /><p />\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   * <p /><p />\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<T, TVariables = OperationVariables>(\n    options: WatchQueryOptions<TVariables>,\n  ): ObservableQuery<T> {\n    if (this.defaultOptions.watchQuery) {\n      options = {\n        ...this.defaultOptions.watchQuery,\n        ...options,\n      } as WatchQueryOptions<TVariables>;\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (\n      this.disableNetworkFetches &&\n      (options.fetchPolicy === 'network-only' ||\n        options.fetchPolicy === 'cache-and-network')\n    ) {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.initQueryManager().watchQuery<T>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a {@link Promise} which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options An object of type {@link QueryOptions} that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<T, TVariables = OperationVariables>(\n    options: QueryOptions<TVariables>,\n  ): Promise<ApolloQueryResult<T>> {\n    if (this.defaultOptions.query) {\n      options = { ...this.defaultOptions.query, ...options } as QueryOptions<\n        TVariables\n      >;\n    }\n\n    if (options.fetchPolicy === 'cache-and-network') {\n      throw new Error(\n        'cache-and-network fetchPolicy can only be used with watchQuery',\n      );\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long\n    // term...\n    if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.initQueryManager().query<T>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * {@link Promise} which is either resolved with the resulting data or rejected with an\n   * error.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<T, TVariables = OperationVariables>(\n    options: MutationOptions<T, TVariables>,\n  ): Promise<FetchResult<T>> {\n    if (this.defaultOptions.mutate) {\n      options = {\n        ...this.defaultOptions.mutate,\n        ...options,\n      } as MutationOptions<T, TVariables>;\n    }\n\n    return this.initQueryManager().mutate<T>(options);\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * {@link Observable} which either emits received data or an error.\n   */\n  public subscribe<T = any, TVariables = OperationVariables>(\n    options: SubscriptionOptions<TVariables>,\n  ): Observable<T> {\n    return this.initQueryManager().startGraphQLSubscription(options);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic Set to `true` to allow `readQuery` to return\n   * optimisic results. Is `false` by default.\n   */\n  public readQuery<T, TVariables = OperationVariables>(\n    options: DataProxy.Query<TVariables>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.initProxy().readQuery<T>(options, optimistic);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic Set to `true` to allow `readFragment` to return\n   * optimisic results. Is `false` by default.\n   */\n  public readFragment<T, TVariables = OperationVariables>(\n    options: DataProxy.Fragment<TVariables>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.initProxy().readFragment<T>(options, optimistic);\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  public writeQuery<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>,\n  ): void {\n    const result = this.initProxy().writeQuery(options);\n    this.initQueryManager().broadcastQueries();\n    return result;\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>,\n  ): void {\n    const result = this.initProxy().writeFragment(options);\n    this.initQueryManager().broadcastQueries();\n    return result;\n  }\n\n  /**\n   * Sugar for writeQuery & writeFragment\n   * This method will construct a query from the data object passed in.\n   * If no id is supplied, writeData will write the data to the root.\n   * If an id is supplied, writeData will write a fragment to the object\n   * specified by the id in the store.\n   *\n   * Since you aren't passing in a query to check the shape of the data,\n   * you must pass in an object that conforms to the shape of valid GraphQL data.\n   */\n  public writeData<TData = any>(\n    options: DataProxy.WriteDataOptions<TData>,\n  ): void {\n    const result = this.initProxy().writeData(options);\n    this.initQueryManager().broadcastQueries();\n    return result;\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(payload: GraphQLRequest): Observable<ExecutionResult> {\n    return execute(this.link, payload);\n  }\n\n  /**\n   * This initializes the query manager that tracks queries and the cache\n   */\n  public initQueryManager(): QueryManager<TCacheShape> {\n    if (!this.queryManager) {\n      this.queryManager = new QueryManager({\n        link: this.link,\n        store: this.store,\n        queryDeduplication: this.queryDeduplication,\n        ssrMode: this.ssrMode,\n        onBroadcast: () => {\n          if (this.devToolsHookCb) {\n            this.devToolsHookCb({\n              action: {},\n              state: {\n                queries: this.queryManager\n                  ? this.queryManager.queryStore.getStore()\n                  : {},\n                mutations: this.queryManager\n                  ? this.queryManager.mutationStore.getStore()\n                  : {},\n              },\n              dataWithOptimisticResults: this.cache.extract(true),\n            });\n          }\n        },\n      });\n    }\n    return this.queryManager;\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. Youâ€™ve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<ApolloQueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() => {\n        return this.queryManager\n          ? this.queryManager.clearStore()\n          : Promise.resolve(null);\n      })\n      .then(() => Promise.all(this.resetStoreCallbacks.map(fn => fn())))\n      .then(() => {\n        return this.queryManager && this.queryManager.reFetchObservableQueries\n          ? this.queryManager.reFetchObservableQueries()\n          : Promise.resolve(null);\n      });\n  }\n\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  public clearStore(): Promise<void | null> {\n    const { queryManager } = this;\n    return Promise.resolve().then(\n      () => (queryManager ? queryManager.clearStore() : Promise.resolve(null)),\n    );\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed with the store is reset.\n   * onResetStore returns an unsubscribe function for removing your registered callbacks.\n   */\n\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  public reFetchObservableQueries(\n    includeStandby?: boolean,\n  ): Promise<ApolloQueryResult<any>[]> | Promise<null> {\n    return this.queryManager\n      ? this.queryManager.reFetchObservableQueries(includeStandby)\n      : Promise.resolve(null);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public extract(optimistic?: boolean): TCacheShape {\n    return this.initProxy().extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: TCacheShape): ApolloCache<TCacheShape> {\n    return this.initProxy().restore(serializedState);\n  }\n\n  /**\n   * Initializes a data proxy for this client instance if one does not already\n   * exist and returns either a previously initialized proxy instance or the\n   * newly initialized instance.\n   */\n  private initProxy(): ApolloCache<TCacheShape> {\n    if (!this.proxy) {\n      this.initQueryManager();\n      this.proxy = this.cache;\n    }\n    return this.proxy;\n  }\n}\n"],"names":["NetworkStatus","LinkObservable","__extends","FetchType","isEqual","tryFunctionOrLogError","__assign","print","ApolloLink","Deduplicator","assign","getDefaultValues","getMutationDefinition","graphQLResultHasError","execute","hasDirectives","isProduction","getQueryDefinition","getOperationDefinition","getOperationName","removeConnectionDirectiveFromDocument"],"mappings":"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"}