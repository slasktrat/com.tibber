{"version":3,"file":"bundle.umd.js","sources":["../src/fixPolyfills.ts","../src/fragmentMatcher.ts","../src/optimism.ts","../src/depTrackingCache.ts","../src/queryKeyMaker.ts","../src/readFromStore.ts","../src/objectCache.ts","../src/writeToStore.ts","../src/recordingCache.ts","../src/inMemoryCache.ts"],"sourcesContent":["const frozen = {};\nconst frozenTestMap = new Map();\n\nif (typeof Object.freeze === 'function') {\n  Object.freeze(frozen);\n}\n\ntry {\n  // If non-extensible objects can't be stored as keys in a Map, make sure we\n  // do not freeze/seal/etc. an object without first attempting to put it in a\n  // Map. For example, this gives the React Native Map polyfill a chance to tag\n  // objects before they become non-extensible:\n  // https://github.com/facebook/react-native/blob/98a6f19d7c/Libraries/vendor/core/Map.js#L44-L50\n  // https://github.com/apollographql/react-apollo/issues/2442#issuecomment-426489517\n  frozenTestMap.set(frozen, frozen).delete(frozen);\n} catch {\n  const wrap = (method: <T>(obj: T) => T): typeof method => {\n    return method && (obj => {\n      try {\n        // If .set succeeds, also call .delete to avoid leaking memory.\n        frozenTestMap.set(obj, obj).delete(obj);\n      } finally {\n        // If .set or .delete fails, the exception will be silently swallowed\n        // by this return-from-finally statement:\n        return method.call(Object, obj);\n      }\n    });\n  };\n  Object.freeze = wrap(Object.freeze);\n  Object.seal = wrap(Object.seal);\n  Object.preventExtensions = wrap(Object.preventExtensions);\n}\n","import { isTest, warnOnceInDevelopment, IdValue } from 'apollo-utilities';\n\nimport {\n  ReadStoreContext,\n  FragmentMatcherInterface,\n  PossibleTypesMap,\n  IntrospectionResultData,\n} from './types';\n\nlet haveWarned = false;\n\n/**\n * This fragment matcher is very basic and unable to match union or interface type conditions\n */\nexport class HeuristicFragmentMatcher implements FragmentMatcherInterface {\n  constructor() {\n    // do nothing\n  }\n\n  public ensureReady() {\n    return Promise.resolve();\n  }\n\n  public canBypassInit() {\n    return true; // we don't need to initialize this fragment matcher.\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ): boolean | 'heuristic' {\n    const obj = context.store.get(idValue.id);\n\n    if (!obj && idValue.id === 'ROOT_QUERY') {\n      return true;\n    }\n\n    if (!obj) {\n      return false;\n    }\n\n    if (!obj.__typename) {\n      if (!haveWarned) {\n        console.warn(`You're using fragments in your queries, but either don't have the addTypename:\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\n   can accurately match fragments.`);\n        console.warn(\n          'Could not find __typename on Fragment ',\n          typeCondition,\n          obj,\n        );\n        console.warn(\n          `DEPRECATION WARNING: using fragments without __typename is unsupported behavior ` +\n            `and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.`,\n        );\n\n        /* istanbul ignore if */\n        if (!isTest()) {\n          // When running tests, we want to print the warning every time\n          haveWarned = true;\n        }\n      }\n\n      return 'heuristic';\n    }\n\n    if (obj.__typename === typeCondition) {\n      return true;\n    }\n\n    // XXX here we reach an issue - we don't know if this fragment should match or not. It's either:\n    // 1. A fragment on a non-matching concrete type or interface or union\n    // 2. A fragment on a matching interface or union\n    // If it's 1, we don't want to return anything, if it's 2 we want to match. We can't tell the\n    // difference, so we warn the user, but still try to match it (backcompat).\n    warnOnceInDevelopment(\n      'You are using the simple (heuristic) fragment matcher, but your ' +\n        'queries contain union or interface types. Apollo Client will not be ' +\n        'able to accurately map fragments. To make this error go away, use ' +\n        'the `IntrospectionFragmentMatcher` as described in the docs: ' +\n        'https://www.apollographql.com/docs/react/recipes/fragment-matching.html',\n      'error',\n    );\n\n    return 'heuristic';\n  }\n}\n\nexport class IntrospectionFragmentMatcher implements FragmentMatcherInterface {\n  private isReady: boolean;\n  private possibleTypesMap: PossibleTypesMap;\n\n  constructor(options?: {\n    introspectionQueryResultData?: IntrospectionResultData;\n  }) {\n    if (options && options.introspectionQueryResultData) {\n      this.possibleTypesMap = this.parseIntrospectionResult(\n        options.introspectionQueryResultData,\n      );\n      this.isReady = true;\n    } else {\n      this.isReady = false;\n    }\n\n    this.match = this.match.bind(this);\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ) {\n    if (!this.isReady) {\n      // this should basically never happen in proper use.\n      throw new Error(\n        'FragmentMatcher.match() was called before FragmentMatcher.init()',\n      );\n    }\n\n    const obj = context.store.get(idValue.id);\n\n    if (!obj) {\n      return false;\n    }\n\n    if (!obj.__typename) {\n      throw new Error(\n        `Cannot match fragment because __typename property is missing: ${JSON.stringify(\n          obj,\n        )}`,\n      );\n    }\n\n    if (obj.__typename === typeCondition) {\n      return true;\n    }\n\n    const implementingTypes = this.possibleTypesMap[typeCondition];\n    if (implementingTypes && implementingTypes.indexOf(obj.__typename) > -1) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private parseIntrospectionResult(\n    introspectionResultData: IntrospectionResultData,\n  ): PossibleTypesMap {\n    const typeMap: PossibleTypesMap = {};\n    introspectionResultData.__schema.types.forEach(type => {\n      if (type.kind === 'UNION' || type.kind === 'INTERFACE') {\n        typeMap[type.name] = type.possibleTypes.map(\n          implementingType => implementingType.name,\n        );\n      }\n    });\n    return typeMap;\n  }\n}\n","declare function require(id: string): any;\n\nexport type OptimisticWrapperFunction<\n  T = (...args: any[]) => any,\n> = T & {\n  // The .dirty(...) method of an optimistic function takes exactly the same\n  // parameter types as the original function.\n  dirty: T;\n};\n\nexport type OptimisticWrapOptions = {\n  max?: number;\n  disposable?: boolean;\n  makeCacheKey?(...args: any[]): any;\n};\n\nconst { wrap }: {\n  wrap<T>(\n    originalFunction: T,\n    options?: OptimisticWrapOptions,\n  ): OptimisticWrapperFunction<T>;\n} = require('optimism'); // tslint:disable-line\n\nexport { wrap };\n\nexport class CacheKeyNode<KeyType = object> {\n  private children: Map<any, CacheKeyNode<KeyType>> | null = null;\n  private key: KeyType | null = null;\n\n  lookup(...args: any[]): KeyType {\n    return this.lookupArray(args);\n  }\n\n  lookupArray(array: any[]): KeyType {\n    let node: CacheKeyNode<KeyType> = this;\n    array.forEach(value => {\n      node = node.getOrCreate(value);\n    });\n    return node.key || (node.key = Object.create(null));\n  }\n\n  getOrCreate(value: any): CacheKeyNode<KeyType> {\n    const map = this.children || (this.children = new Map);\n    return map.get(value) || map.set(value, new CacheKeyNode<KeyType>()).get(value);\n  }\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\nimport { wrap, OptimisticWrapperFunction } from './optimism';\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nexport class DepTrackingCache implements NormalizedCache {\n  // Wrapper function produced by the optimism library, used to depend on\n  // dataId strings, for easy invalidation of specific IDs.\n  private depend: OptimisticWrapperFunction<(dataId: string) => StoreObject>;\n\n  constructor(private data: NormalizedCacheObject = Object.create(null)) {\n    this.depend = wrap((\n      dataId: string,\n    ) => this.data[dataId], {\n      disposable: true,\n      makeCacheKey(dataId: string) {\n        return dataId;\n      }\n    });\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return this.data;\n  }\n\n  public get(dataId: string): StoreObject {\n    this.depend(dataId);\n    return this.data[dataId];\n  }\n\n  public set(dataId: string, value: StoreObject) {\n    const oldValue = this.data[dataId];\n    if (value !== oldValue) {\n      this.data[dataId] = value;\n      this.depend.dirty(dataId);\n    }\n  }\n\n  public delete(dataId: string): void {\n    if (hasOwn.call(this.data, dataId)) {\n      delete this.data[dataId];\n      this.depend.dirty(dataId);\n    }\n  }\n\n  public clear(): void {\n    this.replace(null);\n  }\n\n  public replace(newData: NormalizedCacheObject): void {\n    if (newData) {\n      Object.keys(newData).forEach(dataId => {\n        this.set(dataId, newData[dataId]);\n      });\n      Object.keys(this.data).forEach(dataId => {\n        if (! hasOwn.call(newData, dataId)) {\n          this.delete(dataId);\n        }\n      });\n    } else {\n      Object.keys(this.data).forEach(dataId => {\n        this.delete(dataId);\n      });\n    }\n  }\n}\n\nexport function defaultNormalizedCacheFactory(\n  seed?: NormalizedCacheObject,\n): NormalizedCache {\n  return new DepTrackingCache(seed);\n}\n","import { CacheKeyNode } from \"./optimism\";\nimport { DocumentNode, SelectionSetNode, FragmentSpreadNode, FragmentDefinitionNode } from \"graphql\";\nimport { QueryDocumentKeys } from \"graphql/language/visitor\";\n\nconst CIRCULAR = Object.create(null);\nconst objToStr = Object.prototype.toString;\n\nexport class QueryKeyMaker {\n  private perQueryKeyMakers = new Map<DocumentNode, PerQueryKeyMaker>();\n\n  constructor(private cacheKeyRoot: CacheKeyNode) {}\n\n  public forQuery(document: DocumentNode) {\n    if (! this.perQueryKeyMakers.has(document)) {\n      this.perQueryKeyMakers.set(\n        document,\n        new PerQueryKeyMaker(this.cacheKeyRoot, document),\n      );\n    }\n    return this.perQueryKeyMakers.get(document);\n  }\n}\n\nclass PerQueryKeyMaker {\n  private cache = new Map;\n\n  constructor(\n    private cacheKeyRoot: CacheKeyNode,\n    private query: DocumentNode,\n  ) {\n    this.lookupArray = this.cacheMethod(this.lookupArray);\n    this.lookupObject = this.cacheMethod(this.lookupObject);\n    this.lookupFragmentSpread = this.cacheMethod(this.lookupFragmentSpread);\n  }\n\n  private cacheMethod<V, R>(method: (value: V) => R): typeof method {\n    return (value: V) => {\n      if (this.cache.has(value)) {\n        const cached = this.cache.get(value);\n        if (cached === CIRCULAR) {\n          throw new Error(\"QueryKeyMaker cannot handle circular query structures\");\n        }\n        return cached;\n      }\n      this.cache.set(value, CIRCULAR);\n      try {\n        const result = method.call(this, value);\n        this.cache.set(value, result);\n        return result;\n      } catch (e) {\n        this.cache.delete(value);\n        throw e;\n      }\n    };\n  }\n\n  public lookupQuery(document: DocumentNode): object {\n    return this.lookupObject(document);\n  }\n\n  public lookupSelectionSet(selectionSet: SelectionSetNode) {\n    return this.lookupObject(selectionSet);\n  }\n\n  private lookupFragmentSpread(fragmentSpread: FragmentSpreadNode): object {\n    const name = fragmentSpread.name.value;\n    let fragment: FragmentDefinitionNode = null;\n\n    this.query.definitions.some(definition => {\n      if (definition.kind === \"FragmentDefinition\" &&\n          definition.name.value === name) {\n        fragment = definition;\n        return true;\n      }\n    });\n\n    // Include the key object computed from the FragmentDefinition named by\n    // this FragmentSpreadNode.\n    return this.lookupObject({\n      ...fragmentSpread,\n      fragment,\n    });\n  }\n\n  private lookupAny(value: any): object {\n    if (Array.isArray(value)) {\n      return this.lookupArray(value);\n    }\n\n    if (typeof value === \"object\" && value !== null) {\n      if (value.kind === \"FragmentSpread\") {\n        return this.lookupFragmentSpread(value);\n      }\n      return this.lookupObject(value);\n    }\n\n    return value;\n  }\n\n  private lookupArray(array: any[]): object {\n    const elements = array.map(this.lookupAny, this);\n    return this.cacheKeyRoot.lookup(\n      objToStr.call(array),\n      this.cacheKeyRoot.lookupArray(elements),\n    );\n  }\n\n  private lookupObject(object: { [key: string]: any }): object {\n    const keys = safeSortedKeys(object);\n    const values = keys.map(key => this.lookupAny(object[key]));\n    return this.cacheKeyRoot.lookup(\n      objToStr.call(object),\n      this.cacheKeyRoot.lookupArray(keys),\n      this.cacheKeyRoot.lookupArray(values),\n    );\n  }\n}\n\nconst queryKeyMap: {\n  [key: string]: { [key: string]: boolean }\n} = Object.create(null);\n\nObject.keys(QueryDocumentKeys).forEach(parentKind => {\n  const childKeys = queryKeyMap[parentKind] = Object.create(null);\n\n  (QueryDocumentKeys as {\n    [key: string]: any[]\n  })[parentKind].forEach(childKey => {\n    childKeys[childKey] = true;\n  });\n\n  if (parentKind === \"FragmentSpread\") {\n    // A custom key that we include when looking up FragmentSpread nodes.\n    childKeys[\"fragment\"] = true;\n  }\n});\n\nfunction safeSortedKeys(object: { [key: string]: any }): string[] {\n  const keys = Object.keys(object);\n  const keyCount = keys.length;\n  const knownKeys = typeof object.kind === \"string\" && queryKeyMap[object.kind];\n\n  // Remove unknown object-valued keys from the array, but leave keys with\n  // non-object values untouched.\n  let target = 0;\n  for (let source = target; source < keyCount; ++source) {\n    const key = keys[source];\n    const value = object[key];\n    const isObjectOrArray = value !== null && typeof value === \"object\";\n    if (! isObjectOrArray || ! knownKeys || knownKeys[key] === true) {\n      keys[target++] = key;\n    }\n  }\n  keys.length = target;\n\n  return keys.sort();\n}\n","import {\n  assign,\n  getDefaultValues,\n  getQueryDefinition,\n  isEqual,\n  DirectiveInfo,\n  FragmentMap,\n  IdValue,\n  StoreValue,\n  argumentsObjectFromField,\n  createFragmentMap,\n  getDirectiveInfoFromField,\n  getFragmentDefinitions,\n  getMainDefinition,\n  getStoreKeyName,\n  isField,\n  isIdValue,\n  isInlineFragment,\n  isJsonValue,\n  resultKeyNameFromField,\n  shouldInclude,\n  toIdValue,\n} from 'apollo-utilities';\n\nimport { Cache } from 'apollo-cache';\n\nimport {\n  ReadStoreContext,\n  DiffQueryAgainstStoreOptions,\n  ReadQueryOptions,\n  StoreObject,\n} from './types';\n\nimport {\n  DocumentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n  SelectionSetNode,\n} from 'graphql';\n\nimport { wrap, CacheKeyNode } from './optimism';\nexport { OptimisticWrapperFunction } from './optimism';\n\nimport { DepTrackingCache } from './depTrackingCache';\nimport { QueryKeyMaker } from './queryKeyMaker';\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: ReadStoreContext,\n) => boolean | 'heuristic';\n\ntype ExecContext = {\n  query: DocumentNode;\n  fragmentMap: FragmentMap;\n  contextValue: ReadStoreContext;\n  variableValues: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n};\n\ntype ExecInfo = {\n  resultKey: string;\n  directives: DirectiveInfo;\n};\n\nexport type ExecResultMissingField = {\n  object: StoreObject;\n  fieldName: string;\n  tolerable: boolean;\n};\n\nexport type ExecResult<R = any> = {\n  result: R;\n  // Empty array if no missing fields encountered while computing result.\n  missing?: ExecResultMissingField[];\n};\n\ntype ExecStoreQueryOptions = {\n  query: DocumentNode;\n  rootValue: IdValue;\n  contextValue: ReadStoreContext;\n  variableValues: VariableMap;\n  // Default matcher always matches all fragments\n  fragmentMatcher: FragmentMatcher;\n};\n\ntype ExecSelectionSetOptions = {\n  selectionSet: SelectionSetNode;\n  rootValue: any;\n  execContext: ExecContext;\n};\n\nexport class StoreReader {\n  private keyMaker: QueryKeyMaker;\n\n  constructor(\n    private cacheKeyRoot = new CacheKeyNode,\n  ) {\n    const reader = this;\n    const {\n      executeStoreQuery,\n      executeSelectionSet,\n    } = reader;\n\n    reader.keyMaker = new QueryKeyMaker(cacheKeyRoot);\n\n    this.executeStoreQuery = wrap((options: ExecStoreQueryOptions) => {\n      return executeStoreQuery.call(this, options);\n    }, {\n      makeCacheKey({\n        query,\n        rootValue,\n        contextValue,\n        variableValues,\n        fragmentMatcher,\n      }: ExecStoreQueryOptions) {\n        // The result of executeStoreQuery can be safely cached only if the\n        // underlying store is capable of tracking dependencies and invalidating\n        // the cache when relevant data have changed.\n        if (contextValue.store instanceof DepTrackingCache) {\n          return reader.cacheKeyRoot.lookup(\n            reader.keyMaker.forQuery(query).lookupQuery(query),\n            contextValue.store,\n            fragmentMatcher,\n            JSON.stringify(variableValues),\n            rootValue.id,\n          );\n        }\n      }\n    });\n\n    this.executeSelectionSet = wrap((options: ExecSelectionSetOptions) => {\n      return executeSelectionSet.call(this, options);\n    }, {\n      makeCacheKey({\n        selectionSet,\n        rootValue,\n        execContext,\n      }: ExecSelectionSetOptions) {\n        if (execContext.contextValue.store instanceof DepTrackingCache) {\n          return reader.cacheKeyRoot.lookup(\n            reader.keyMaker.forQuery(execContext.query).lookupSelectionSet(selectionSet),\n            execContext.contextValue.store,\n            execContext.fragmentMatcher,\n            JSON.stringify(execContext.variableValues),\n            rootValue.id,\n          );\n        }\n      }\n    });\n  }\n\n  /**\n   * Resolves the result of a query solely from the store (i.e. never hits the server).\n   *\n   * @param {Store} store The {@link NormalizedCache} used by Apollo for the `data` portion of the\n   * store.\n   *\n   * @param {DocumentNode} query The query document to resolve from the data available in the store.\n   *\n   * @param {Object} [variables] A map from the name of a variable to its value. These variables can\n   * be referenced by the query document.\n   *\n   * @param {any} previousResult The previous result returned by this function for the same query.\n   * If nothing in the store changed since that previous result then values from the previous result\n   * will be returned to preserve referential equality.\n   */\n  public readQueryFromStore<QueryType>(\n    options: ReadQueryOptions,\n  ): QueryType {\n    const optsPatch = { returnPartialData: false };\n\n    return this.diffQueryAgainstStore<QueryType>({\n      ...options,\n      ...optsPatch,\n    }).result;\n  }\n\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   * @param  {DocumentNode} query A parsed GraphQL query document\n   * @param  {Store} store The Apollo Client store object\n   * @param  {any} previousResult The previous result returned by this function for the same query\n   * @return {result: Object, complete: [boolean]}\n   */\n  public diffQueryAgainstStore<T>({\n    store,\n    query,\n    variables,\n    previousResult,\n    returnPartialData = true,\n    rootId = 'ROOT_QUERY',\n    fragmentMatcherFunction,\n    config,\n  }: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n    // Throw the right validation error by trying to find a query in the document\n    const queryDefinition = getQueryDefinition(query);\n\n    variables = assign({}, getDefaultValues(queryDefinition), variables);\n\n    const context: ReadStoreContext = {\n      // Global settings\n      store,\n      dataIdFromObject: (config && config.dataIdFromObject) || null,\n      cacheRedirects: (config && config.cacheRedirects) || {},\n    };\n\n    const execResult = this.executeStoreQuery({\n      query,\n      rootValue: {\n        type: 'id',\n        id: rootId,\n        generated: true,\n        typename: 'Query',\n      },\n      contextValue: context,\n      variableValues: variables,\n      fragmentMatcher: fragmentMatcherFunction,\n    });\n\n    const hasMissingFields =\n      execResult.missing && execResult.missing.length > 0;\n\n    if (hasMissingFields && ! returnPartialData) {\n      execResult.missing.forEach(info => {\n        if (info.tolerable) return;\n        throw new Error(\n          `Can't find field ${info.fieldName} on object ${JSON.stringify(\n            info.object,\n            null,\n            2,\n          )}.`,\n        );\n      });\n    }\n\n    if (previousResult) {\n      if (isEqual(previousResult, execResult.result)) {\n        execResult.result = previousResult;\n      }\n    }\n\n    return {\n      result: execResult.result,\n      complete: !hasMissingFields,\n    };\n  }\n\n  /**\n   * Based on graphql function from graphql-js:\n   *\n   * graphql(\n   *   schema: GraphQLSchema,\n   *   requestString: string,\n   *   rootValue?: ?any,\n   *   contextValue?: ?any,\n   *   variableValues?: ?{[key: string]: any},\n   *   operationName?: ?string\n   * ): Promise<GraphQLResult>\n   *\n   * The default export as of graphql-anywhere is sync as of 4.0,\n   * but below is an exported alternative that is async.\n   * In the 5.0 version, this will be the only export again\n   * and it will be async\n   *\n   */\n  private executeStoreQuery({\n    query,\n    rootValue,\n    contextValue,\n    variableValues,\n    // Default matcher always matches all fragments\n    fragmentMatcher = defaultFragmentMatcher,\n  }: ExecStoreQueryOptions): ExecResult {\n    const mainDefinition = getMainDefinition(query);\n    const fragments = getFragmentDefinitions(query);\n    const fragmentMap = createFragmentMap(fragments);\n    const execContext: ExecContext = {\n      query,\n      fragmentMap,\n      contextValue,\n      variableValues,\n      fragmentMatcher,\n    };\n\n    return this.executeSelectionSet({\n      selectionSet: mainDefinition.selectionSet,\n      rootValue,\n      execContext,\n    });\n  }\n\n  private executeSelectionSet({\n    selectionSet,\n    rootValue,\n    execContext,\n  }: ExecSelectionSetOptions): ExecResult {\n    const { fragmentMap, contextValue, variableValues: variables } = execContext;\n    const finalResult: ExecResult = {\n      result: {},\n    };\n\n    const object: StoreObject = contextValue.store.get(rootValue.id);\n\n    const typename =\n      (object && object.__typename) ||\n      (rootValue.id === 'ROOT_QUERY' && 'Query') ||\n      void 0;\n\n    function handleMissing<T>(result: ExecResult<T>): T {\n      if (result.missing) {\n        finalResult.missing = finalResult.missing || [];\n        finalResult.missing.push(...result.missing);\n      }\n      return result.result;\n    }\n\n    selectionSet.selections.forEach(selection => {\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely\n        return;\n      }\n\n      if (isField(selection)) {\n        const fieldResult = handleMissing(\n          this.executeField(object, typename, selection, execContext),\n        );\n\n        if (typeof fieldResult !== 'undefined') {\n          merge(finalResult.result, {\n            [resultKeyNameFromField(selection)]: fieldResult,\n          });\n        }\n\n      } else {\n        let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n        if (isInlineFragment(selection)) {\n          fragment = selection;\n        } else {\n          // This is a named fragment\n          fragment = fragmentMap[selection.name.value];\n\n          if (!fragment) {\n            throw new Error(`No fragment named ${selection.name.value}`);\n          }\n        }\n\n        const typeCondition = fragment.typeCondition.name.value;\n\n        const match = execContext.fragmentMatcher(rootValue, typeCondition, contextValue);\n        if (match) {\n          let fragmentExecResult = this.executeSelectionSet({\n            selectionSet: fragment.selectionSet,\n            rootValue,\n            execContext,\n          });\n\n          if (match === 'heuristic' && fragmentExecResult.missing) {\n            fragmentExecResult = {\n              ...fragmentExecResult,\n              missing: fragmentExecResult.missing.map(info => {\n                return { ...info, tolerable: true };\n              }),\n            };\n          }\n\n          merge(finalResult.result, handleMissing(fragmentExecResult));\n        }\n      }\n    });\n\n    return finalResult;\n  }\n\n  private executeField(\n    object: StoreObject,\n    typename: string | void,\n    field: FieldNode,\n    execContext: ExecContext,\n  ): ExecResult {\n    const { variableValues: variables, contextValue } = execContext;\n    const fieldName = field.name.value;\n    const args = argumentsObjectFromField(field, variables);\n\n    const info: ExecInfo = {\n      resultKey: resultKeyNameFromField(field),\n      directives: getDirectiveInfoFromField(field, variables),\n    };\n\n    const readStoreResult = readStoreResolver(\n      object,\n      typename,\n      fieldName,\n      args,\n      contextValue,\n      info,\n    );\n\n    // Handle all scalar types here\n    if (!field.selectionSet) {\n      return readStoreResult;\n    }\n\n    // From here down, the field has a selection set, which means it's trying to\n    // query a GraphQLObjectType\n    if (readStoreResult.result == null) {\n      // Basically any field in a GraphQL response can be null, or missing\n      return readStoreResult;\n    }\n\n    function handleMissing<T>(res: ExecResult<T>): ExecResult<T> {\n      let missing: ExecResultMissingField[] = null;\n\n      if (readStoreResult.missing) {\n        missing = missing || [];\n        missing.push(...readStoreResult.missing);\n      }\n\n      if (res.missing) {\n        missing = missing || [];\n        missing.push(...res.missing);\n      }\n\n      return {\n        result: res.result,\n        missing,\n      };\n    }\n\n    if (Array.isArray(readStoreResult.result)) {\n      return handleMissing(this.executeSubSelectedArray(\n        field,\n        readStoreResult.result,\n        execContext,\n      ));\n    }\n\n    // Returned value is an object, and the query has a sub-selection. Recurse.\n    return handleMissing(this.executeSelectionSet({\n      selectionSet: field.selectionSet,\n      rootValue: readStoreResult.result,\n      execContext,\n    }));\n  }\n\n  private executeSubSelectedArray(\n    field: FieldNode,\n    result: any[],\n    execContext: ExecContext,\n  ): ExecResult {\n    let missing: ExecResultMissingField[] = null;\n\n    function handleMissing<T>(childResult: ExecResult<T>): T {\n      if (childResult.missing) {\n        missing = missing || [];\n        missing.push(...childResult.missing);\n      }\n\n      return childResult.result;\n    }\n\n    result = result.map(item => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n\n      // This is a nested array, recurse\n      if (Array.isArray(item)) {\n        return handleMissing(this.executeSubSelectedArray(field, item, execContext));\n      }\n\n      // This is an object, run the selection set on it\n      return handleMissing(this.executeSelectionSet({\n        selectionSet: field.selectionSet,\n        rootValue: item,\n        execContext,\n      }));\n    });\n\n    return { result, missing };\n  }\n}\n\nfunction defaultFragmentMatcher() {\n  return true;\n}\n\nexport function assertIdValue(idValue: IdValue) {\n  if (!isIdValue(idValue)) {\n    throw new Error(`Encountered a sub-selection on the query, but the store doesn't have \\\nan object reference. This should never happen during normal use unless you have custom code \\\nthat is directly manipulating the store; please file an issue.`);\n  }\n}\n\nfunction readStoreResolver(\n  object: StoreObject,\n  typename: string | void,\n  fieldName: string,\n  args: any,\n  context: ReadStoreContext,\n  { resultKey, directives }: ExecInfo,\n): ExecResult<StoreValue> {\n  let storeKeyName = fieldName;\n  if (args || directives) {\n    // We happen to know here that getStoreKeyName returns its first\n    // argument unmodified if there are no args or directives, so we can\n    // avoid calling the function at all in that case, as a small but\n    // important optimization to this frequently executed code.\n    storeKeyName = getStoreKeyName(storeKeyName, args, directives);\n  }\n\n  let fieldValue: StoreValue | void = void 0;\n\n  if (object) {\n    fieldValue = object[storeKeyName];\n\n    if (\n      typeof fieldValue === 'undefined' &&\n      context.cacheRedirects &&\n      typeof typename === 'string'\n    ) {\n      // Look for the type in the custom resolver map\n      const type = context.cacheRedirects[typename];\n      if (type) {\n        // Look for the field in the custom resolver map\n        const resolver = type[fieldName];\n        if (resolver) {\n          fieldValue = resolver(object, args, {\n            getCacheKey(storeObj: StoreObject) {\n              return toIdValue({\n                id: context.dataIdFromObject(storeObj),\n                typename: storeObj.__typename,\n              });\n            },\n          });\n        }\n      }\n    }\n  }\n\n  if (typeof fieldValue === 'undefined') {\n    return {\n      result: fieldValue,\n      missing: [{\n        object,\n        fieldName: storeKeyName,\n        tolerable: false,\n      }],\n    };\n  }\n\n  if (isJsonValue(fieldValue)) {\n    fieldValue = fieldValue.json;\n  }\n\n  return {\n    result: fieldValue,\n  };\n}\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nfunction merge(\n  target: { [key: string]: any },\n  source: { [key: string]: any },\n) {\n  if (source !== null && typeof source === 'object' &&\n      // Due to result caching, it's possible that source and target will\n      // be === at some point in the tree, which means we can stop early.\n      source !== target) {\n\n    // In case the target has been frozen, make an extensible copy so that\n    // we can merge properties into the copy.\n    if (Object.isExtensible && !Object.isExtensible(target)) {\n      target = { ...target };\n    }\n\n    Object.keys(source).forEach(sourceKey => {\n      const sourceVal = source[sourceKey];\n      if (!hasOwn.call(target, sourceKey)) {\n        target[sourceKey] = sourceVal;\n      } else {\n        target[sourceKey] = merge(target[sourceKey], sourceVal);\n      }\n    });\n  }\n\n  return target;\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\n\nexport class ObjectCache implements NormalizedCache {\n  constructor(private data: NormalizedCacheObject = Object.create(null)) {}\n  public toObject(): NormalizedCacheObject {\n    return this.data;\n  }\n  public get(dataId: string): StoreObject {\n    return this.data[dataId];\n  }\n  public set(dataId: string, value: StoreObject) {\n    this.data[dataId] = value;\n  }\n  public delete(dataId: string): void {\n    this.data[dataId] = undefined;\n  }\n  public clear(): void {\n    this.data = Object.create(null);\n  }\n  public replace(newData: NormalizedCacheObject): void {\n    this.data = newData || Object.create(null);\n  }\n}\n\nexport function defaultNormalizedCacheFactory(\n  seed?: NormalizedCacheObject,\n): NormalizedCache {\n  return new ObjectCache(seed);\n}\n","import {\n  SelectionSetNode,\n  FieldNode,\n  DocumentNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n} from 'graphql';\nimport { print } from 'graphql/language/printer';\nimport { FragmentMatcher } from './readFromStore';\n\nimport {\n  assign,\n  createFragmentMap,\n  FragmentMap,\n  getDefaultValues,\n  getFragmentDefinitions,\n  getOperationDefinition,\n  IdValue,\n  isField,\n  isIdValue,\n  isInlineFragment,\n  isProduction,\n  resultKeyNameFromField,\n  shouldInclude,\n  storeKeyNameFromField,\n  StoreValue,\n  toIdValue,\n  isEqual,\n} from 'apollo-utilities';\n\nimport { ObjectCache } from './objectCache';\nimport { defaultNormalizedCacheFactory } from './depTrackingCache';\n\nimport {\n  IdGetter,\n  NormalizedCache,\n  ReadStoreContext,\n  StoreObject,\n} from './types';\n\nexport class WriteError extends Error {\n  public type = 'WriteError';\n}\n\nexport function enhanceErrorWithDocument(error: Error, document: DocumentNode) {\n  // XXX A bit hacky maybe ...\n  const enhancedError = new WriteError(\n    `Error writing result to store for query:\\n ${print(document)}`,\n  );\n  enhancedError.message += '\\n' + error.message;\n  enhancedError.stack = error.stack;\n  return enhancedError;\n}\n\nexport type WriteContext = {\n  readonly store: NormalizedCache;\n  readonly processedData?: { [x: string]: FieldNode[] };\n  readonly variables?: any;\n  readonly dataIdFromObject?: IdGetter;\n  readonly fragmentMap?: FragmentMap;\n  readonly fragmentMatcherFunction?: FragmentMatcher;\n};\n\nexport class StoreWriter {\n  /**\n   * Writes the result of a query to the store.\n   *\n   * @param result The result object returned for the query document.\n   *\n   * @param query The query document whose result we are writing to the store.\n   *\n   * @param store The {@link NormalizedCache} used by Apollo for the `data` portion of the store.\n   *\n   * @param variables A map from the name of a variable to its value. These variables can be\n   * referenced by the query document.\n   *\n   * @param dataIdFromObject A function that returns an object identifier given a particular result\n   * object. See the store documentation for details and an example of this function.\n   *\n   * @param fragmentMatcherFunction A function to use for matching fragment conditions in GraphQL documents\n   */\n  public writeQueryToStore({\n    query,\n    result,\n    store = defaultNormalizedCacheFactory(),\n    variables,\n    dataIdFromObject,\n    fragmentMatcherFunction,\n  }: {\n    query: DocumentNode;\n    result: Object;\n    store?: NormalizedCache;\n    variables?: Object;\n    dataIdFromObject?: IdGetter;\n    fragmentMatcherFunction?: FragmentMatcher;\n  }): NormalizedCache {\n    return this.writeResultToStore({\n      dataId: 'ROOT_QUERY',\n      result,\n      document: query,\n      store,\n      variables,\n      dataIdFromObject,\n      fragmentMatcherFunction,\n    });\n  }\n\n  public writeResultToStore({\n    dataId,\n    result,\n    document,\n    store = defaultNormalizedCacheFactory(),\n    variables,\n    dataIdFromObject,\n    fragmentMatcherFunction,\n  }: {\n    dataId: string;\n    result: any;\n    document: DocumentNode;\n    store?: NormalizedCache;\n    variables?: Object;\n    dataIdFromObject?: IdGetter;\n    fragmentMatcherFunction?: FragmentMatcher;\n  }): NormalizedCache {\n    // XXX TODO REFACTOR: this is a temporary workaround until query normalization is made to work with documents.\n    const operationDefinition = getOperationDefinition(document);\n\n    try {\n      return this.writeSelectionSetToStore({\n        result,\n        dataId,\n        selectionSet: operationDefinition.selectionSet,\n        context: {\n          store,\n          processedData: {},\n          variables: assign(\n            {},\n            getDefaultValues(operationDefinition),\n            variables,\n          ),\n          dataIdFromObject,\n          fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n          fragmentMatcherFunction,\n        },\n      });\n    } catch (e) {\n      throw enhanceErrorWithDocument(e, document);\n    }\n  }\n\n  public writeSelectionSetToStore({\n    result,\n    dataId,\n    selectionSet,\n    context,\n  }: {\n    dataId: string;\n    result: any;\n    selectionSet: SelectionSetNode;\n    context: WriteContext;\n  }): NormalizedCache {\n    const { variables, store, fragmentMap } = context;\n\n    selectionSet.selections.forEach(selection => {\n      if (!shouldInclude(selection, variables)) {\n        return;\n      }\n\n      if (isField(selection)) {\n        const resultFieldKey: string = resultKeyNameFromField(selection);\n        const value: any = result[resultFieldKey];\n\n        if (typeof value !== 'undefined') {\n          this.writeFieldToStore({\n            dataId,\n            value,\n            field: selection,\n            context,\n          });\n        } else {\n          // if this is a defered field we don't need to throw / wanr\n          const isDefered =\n            selection.directives &&\n            selection.directives.length &&\n            selection.directives.some(\n              directive => directive.name && directive.name.value === 'defer',\n            );\n\n          if (!isDefered && context.fragmentMatcherFunction) {\n            // XXX We'd like to throw an error, but for backwards compatibility's sake\n            // we just print a warning for the time being.\n            //throw new WriteError(`Missing field ${resultFieldKey} in ${JSON.stringify(result, null, 2).substring(0, 100)}`);\n            if (!isProduction()) {\n              console.warn(\n                `Missing field ${resultFieldKey} in ${JSON.stringify(\n                  result,\n                  null,\n                  2,\n                ).substring(0, 100)}`,\n              );\n            }\n          }\n        }\n      } else {\n        // This is not a field, so it must be a fragment, either inline or named\n        let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n        if (isInlineFragment(selection)) {\n          fragment = selection;\n        } else {\n          // Named fragment\n          fragment = (fragmentMap || {})[selection.name.value];\n\n          if (!fragment) {\n            throw new Error(`No fragment named ${selection.name.value}.`);\n          }\n        }\n\n        let matches = true;\n        if (context.fragmentMatcherFunction && fragment.typeCondition) {\n          // TODO we need to rewrite the fragment matchers for this to work properly and efficiently\n          // Right now we have to pretend that we're passing in an idValue and that there's a store\n          // on the context.\n          const idValue = toIdValue({ id: 'self', typename: undefined });\n          const fakeContext: ReadStoreContext = {\n            // NOTE: fakeContext always uses ObjectCache\n            // since this is only to ensure the return value of 'matches'\n            store: new ObjectCache({ self: result }),\n            cacheRedirects: {},\n          };\n          const match = context.fragmentMatcherFunction(\n            idValue,\n            fragment.typeCondition.name.value,\n            fakeContext,\n          );\n          if (!isProduction() && match === 'heuristic') {\n            console.error('WARNING: heuristic fragment matching going on!');\n          }\n          matches = !!match;\n        }\n\n        if (matches) {\n          this.writeSelectionSetToStore({\n            result,\n            selectionSet: fragment.selectionSet,\n            dataId,\n            context,\n          });\n        }\n      }\n    });\n\n    return store;\n  }\n\n  private writeFieldToStore({\n    field,\n    value,\n    dataId,\n    context,\n  }: {\n    field: FieldNode;\n    value: any;\n    dataId: string;\n    context: WriteContext;\n  }) {\n    const { variables, dataIdFromObject, store } = context;\n\n    let storeValue: StoreValue;\n    let storeObject: StoreObject;\n\n    const storeFieldName: string = storeKeyNameFromField(field, variables);\n\n    // If this is a scalar value...\n    if (!field.selectionSet || value === null) {\n      storeValue =\n        value != null && typeof value === 'object'\n          ? // If the scalar value is a JSON blob, we have to \"escape\" it so it can’t pretend to be\n            // an id.\n            { type: 'json', json: value }\n          : // Otherwise, just store the scalar directly in the store.\n            value;\n    } else if (Array.isArray(value)) {\n      const generatedId = `${dataId}.${storeFieldName}`;\n\n      storeValue = this.processArrayValue(\n        value,\n        generatedId,\n        field.selectionSet,\n        context,\n      );\n    } else {\n      // It's an object\n      let valueDataId = `${dataId}.${storeFieldName}`;\n      let generated = true;\n\n      // We only prepend the '$' if the valueDataId isn't already a generated\n      // id.\n      if (!isGeneratedId(valueDataId)) {\n        valueDataId = '$' + valueDataId;\n      }\n\n      if (dataIdFromObject) {\n        const semanticId = dataIdFromObject(value);\n\n        // We throw an error if the first character of the id is '$. This is\n        // because we use that character to designate an Apollo-generated id\n        // and we use the distinction between user-desiginated and application-provided\n        // ids when managing overwrites.\n        if (semanticId && isGeneratedId(semanticId)) {\n          throw new Error(\n            'IDs returned by dataIdFromObject cannot begin with the \"$\" character.',\n          );\n        }\n\n        if (\n          semanticId ||\n          (typeof semanticId === 'number' && semanticId === 0)\n        ) {\n          valueDataId = semanticId;\n          generated = false;\n        }\n      }\n\n      if (!isDataProcessed(valueDataId, field, context.processedData)) {\n        this.writeSelectionSetToStore({\n          dataId: valueDataId,\n          result: value,\n          selectionSet: field.selectionSet,\n          context,\n        });\n      }\n\n      // We take the id and escape it (i.e. wrap it with an enclosing object).\n      // This allows us to distinguish IDs from normal scalars.\n      const typename = value.__typename;\n      storeValue = toIdValue({ id: valueDataId, typename }, generated);\n\n      // check if there was a generated id at the location where we're\n      // about to place this new id. If there was, we have to merge the\n      // data from that id with the data we're about to write in the store.\n      storeObject = store.get(dataId);\n      const escapedId =\n        storeObject && (storeObject[storeFieldName] as IdValue | undefined);\n      if (escapedId !== storeValue && isIdValue(escapedId)) {\n        const hadTypename = escapedId.typename !== undefined;\n        const hasTypename = typename !== undefined;\n        const typenameChanged =\n          hadTypename && hasTypename && escapedId.typename !== typename;\n\n        // If there is already a real id in the store and the current id we\n        // are dealing with is generated, we throw an error.\n        // One exception we allow is when the typename has changed, which occurs\n        // when schema defines a union, both with and without an ID in the same place.\n        // checks if we \"lost\" the read id\n        if (generated && !escapedId.generated && !typenameChanged) {\n          throw new Error(\n            `Store error: the application attempted to write an object with no provided id` +\n              ` but the store already contains an id of ${\n                escapedId.id\n              } for this object. The selectionSet` +\n              ` that was trying to be written is:\\n` +\n              print(field),\n          );\n        }\n        // checks if we \"lost\" the typename\n        if (hadTypename && !hasTypename) {\n          throw new Error(\n            `Store error: the application attempted to write an object with no provided typename` +\n              ` but the store already contains an object with typename of ${\n                escapedId.typename\n              } for the object of id ${escapedId.id}. The selectionSet` +\n              ` that was trying to be written is:\\n` +\n              print(field),\n          );\n        }\n\n        if (escapedId.generated) {\n          // We should only merge if it's an object of the same type,\n          // otherwise we should delete the generated object\n          if (typenameChanged) {\n            // Only delete the generated object when the old object was\n            // inlined, and the new object is not. This is indicated by\n            // the old id being generated, and the new id being real.\n            if (!generated) {\n              store.delete(escapedId.id);\n            }\n          } else {\n            mergeWithGenerated(escapedId.id, (storeValue as IdValue).id, store);\n          }\n        }\n      }\n    }\n\n    storeObject = store.get(dataId);\n    if (!storeObject || !isEqual(storeValue, storeObject[storeFieldName])) {\n      store.set(dataId, {\n        ...storeObject,\n        [storeFieldName]: storeValue,\n      });\n    }\n  }\n\n  private processArrayValue(\n    value: any[],\n    generatedId: string,\n    selectionSet: SelectionSetNode,\n    context: WriteContext,\n  ): any[] {\n    return value.map((item: any, index: any) => {\n      if (item === null) {\n        return null;\n      }\n\n      let itemDataId = `${generatedId}.${index}`;\n\n      if (Array.isArray(item)) {\n        return this.processArrayValue(item, itemDataId, selectionSet, context);\n      }\n\n      let generated = true;\n\n      if (context.dataIdFromObject) {\n        const semanticId = context.dataIdFromObject(item);\n\n        if (semanticId) {\n          itemDataId = semanticId;\n          generated = false;\n        }\n      }\n\n      if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {\n        this.writeSelectionSetToStore({\n          dataId: itemDataId,\n          result: item,\n          selectionSet,\n          context,\n        });\n      }\n\n      return toIdValue(\n        { id: itemDataId, typename: item.__typename },\n        generated,\n      );\n    });\n  }\n}\n\n// Checks if the id given is an id that was generated by Apollo\n// rather than by dataIdFromObject.\nfunction isGeneratedId(id: string): boolean {\n  return id[0] === '$';\n}\n\nfunction mergeWithGenerated(\n  generatedKey: string,\n  realKey: string,\n  cache: NormalizedCache,\n): boolean {\n  if (generatedKey === realKey) {\n    return false;\n  }\n\n  const generated = cache.get(generatedKey);\n  const real = cache.get(realKey);\n  let madeChanges = false;\n\n  Object.keys(generated).forEach(key => {\n    const value = generated[key];\n    const realValue = real[key];\n\n    if (isIdValue(value) &&\n        isGeneratedId(value.id) &&\n        isIdValue(realValue) &&\n        ! isEqual(value, realValue) &&\n        mergeWithGenerated(value.id, realValue.id, cache)) {\n      madeChanges = true;\n    }\n  });\n\n  cache.delete(generatedKey);\n  const newRealValue = { ...generated, ...real };\n\n  if (isEqual(newRealValue, real)) {\n    return madeChanges;\n  }\n\n  cache.set(realKey, newRealValue);\n  return true;\n}\n\nfunction isDataProcessed(\n  dataId: string,\n  field: FieldNode | SelectionSetNode,\n  processedData?: { [x: string]: (FieldNode | SelectionSetNode)[] },\n): boolean {\n  if (!processedData) {\n    return false;\n  }\n\n  if (processedData[dataId]) {\n    if (processedData[dataId].indexOf(field) >= 0) {\n      return true;\n    } else {\n      processedData[dataId].push(field);\n    }\n  } else {\n    processedData[dataId] = [field];\n  }\n\n  return false;\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\n\nexport class RecordingCache implements NormalizedCache {\n  private recordedData: NormalizedCacheObject = {};\n\n  constructor(private readonly data: NormalizedCacheObject = {}) {}\n\n  public record(\n    transaction: (recordingCache: RecordingCache) => void,\n  ): NormalizedCacheObject {\n    transaction(this);\n    const recordedData = this.recordedData;\n    this.recordedData = {};\n    return recordedData;\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return { ...this.data, ...this.recordedData };\n  }\n\n  public get(dataId: string): StoreObject {\n    if (this.recordedData.hasOwnProperty(dataId)) {\n      // recording always takes precedence:\n      return this.recordedData[dataId];\n    }\n    return this.data[dataId];\n  }\n\n  public set(dataId: string, value: StoreObject) {\n    if (this.get(dataId) !== value) {\n      this.recordedData[dataId] = value;\n    }\n  }\n\n  public delete(dataId: string): void {\n    this.recordedData[dataId] = undefined;\n  }\n\n  public clear(): void {\n    Object.keys(this.data).forEach(dataId => this.delete(dataId));\n    this.recordedData = {};\n  }\n\n  public replace(newData: NormalizedCacheObject): void {\n    this.clear();\n    this.recordedData = { ...newData };\n  }\n}\n\nexport function record(\n  startingState: NormalizedCacheObject,\n  transaction: (recordingCache: RecordingCache) => void,\n): NormalizedCacheObject {\n  const recordingCache = new RecordingCache(startingState);\n  return recordingCache.record(transaction);\n}\n","// Make builtins like Map and Set safe to use with non-extensible objects.\nimport './fixPolyfills';\n\nimport { DocumentNode } from 'graphql';\n\nimport { Cache, DataProxy, ApolloCache, Transaction } from 'apollo-cache';\n\nimport {\n  getFragmentQueryDocument,\n  addTypenameToDocument,\n} from 'apollo-utilities';\n\nimport { HeuristicFragmentMatcher } from './fragmentMatcher';\nimport {\n  OptimisticStoreItem,\n  ApolloReducerConfig,\n  NormalizedCache,\n  NormalizedCacheObject,\n} from './types';\n\nimport { StoreReader } from './readFromStore';\nimport { StoreWriter } from './writeToStore';\n\nimport { defaultNormalizedCacheFactory, DepTrackingCache } from './depTrackingCache';\nimport { wrap, CacheKeyNode, OptimisticWrapperFunction } from './optimism';\n\nimport { record } from './recordingCache';\nconst defaultConfig: ApolloReducerConfig = {\n  fragmentMatcher: new HeuristicFragmentMatcher(),\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n};\n\nexport function defaultDataIdFromObject(result: any): string | null {\n  if (result.__typename) {\n    if (result.id !== undefined) {\n      return `${result.__typename}:${result.id}`;\n    }\n    if (result._id !== undefined) {\n      return `${result.__typename}:${result._id}`;\n    }\n  }\n  return null;\n}\n\nexport class InMemoryCache extends ApolloCache<NormalizedCacheObject> {\n  protected data: NormalizedCache;\n  protected config: ApolloReducerConfig;\n  protected optimistic: OptimisticStoreItem[] = [];\n  private watches = new Set<Cache.WatchOptions>();\n  private addTypename: boolean;\n  private typenameDocumentCache = new Map<DocumentNode, DocumentNode>();\n  private storeReader: StoreReader;\n  private storeWriter: StoreWriter;\n  private cacheKeyRoot = new CacheKeyNode();\n\n  // Set this while in a transaction to prevent broadcasts...\n  // don't forget to turn it back on!\n  private silenceBroadcast: boolean = false;\n\n  constructor(config: ApolloReducerConfig = {}) {\n    super();\n    this.config = { ...defaultConfig, ...config };\n\n    // backwards compat\n    if ((this.config as any).customResolvers) {\n      console.warn(\n        'customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).customResolvers;\n    }\n\n    if ((this.config as any).cacheResolvers) {\n      console.warn(\n        'cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).cacheResolvers;\n    }\n\n    this.addTypename = this.config.addTypename;\n    this.data = defaultNormalizedCacheFactory();\n\n    this.storeReader = new StoreReader(this.cacheKeyRoot);\n    this.storeWriter = new StoreWriter();\n\n    const cache = this;\n    const { maybeBroadcastWatch } = cache;\n    this.maybeBroadcastWatch = wrap((c: Cache.WatchOptions) => {\n      return maybeBroadcastWatch.call(this, c);\n    }, {\n      makeCacheKey(c: Cache.WatchOptions) {\n        if (c.optimistic && cache.optimistic.length > 0) {\n          // If we're reading optimistic data, it doesn't matter if this.data\n          // is a DepTrackingCache, since it will be ignored.\n          return;\n        }\n\n        if (c.previousResult) {\n          // If a previousResult was provided, assume the caller would prefer\n          // to compare the previous data to the new data to determine whether\n          // to broadcast, so we should disable caching by returning here, to\n          // give maybeBroadcastWatch a chance to do that comparison.\n          return;\n        }\n\n        if (cache.data instanceof DepTrackingCache) {\n          // Return a cache key (thus enabling caching) only if we're currently\n          // using a data store that can track cache dependencies.\n          return cache.cacheKeyRoot.lookup(\n            c.query,\n            JSON.stringify(c.variables),\n          );\n        }\n      }\n    });\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    if (optimistic && this.optimistic.length > 0) {\n      const patches = this.optimistic.map(opt => opt.data);\n      return Object.assign({}, this.data.toObject(), ...patches);\n    }\n\n    return this.data.toObject();\n  }\n\n  public read<T>(query: Cache.ReadOptions): T | null {\n    if (query.rootId && this.data.get(query.rootId) === undefined) {\n      return null;\n    }\n\n    const store = (query.optimistic && this.optimistic.length)\n      ? defaultNormalizedCacheFactory(this.extract(true))\n      : this.data;\n\n    return this.storeReader.readQueryFromStore({\n      store,\n      query: this.transformDocument(query.query),\n      variables: query.variables,\n      rootId: query.rootId,\n      fragmentMatcherFunction: this.config.fragmentMatcher.match,\n      previousResult: query.previousResult,\n      config: this.config,\n    });\n  }\n\n  public write(write: Cache.WriteOptions): void {\n    this.storeWriter.writeResultToStore({\n      dataId: write.dataId,\n      result: write.result,\n      variables: write.variables,\n      document: this.transformDocument(write.query),\n      store: this.data,\n      dataIdFromObject: this.config.dataIdFromObject,\n      fragmentMatcherFunction: this.config.fragmentMatcher.match,\n    });\n\n    this.broadcastWatches();\n  }\n\n  public diff<T>(query: Cache.DiffOptions): Cache.DiffResult<T> {\n    const store = (query.optimistic && this.optimistic.length)\n      ? defaultNormalizedCacheFactory(this.extract(true))\n      : this.data;\n\n    return this.storeReader.diffQueryAgainstStore({\n      store: store,\n      query: this.transformDocument(query.query),\n      variables: query.variables,\n      returnPartialData: query.returnPartialData,\n      previousResult: query.previousResult,\n      fragmentMatcherFunction: this.config.fragmentMatcher.match,\n      config: this.config,\n    });\n  }\n\n  public watch(watch: Cache.WatchOptions): () => void {\n    this.watches.add(watch);\n\n    return () => {\n      this.watches.delete(watch);\n    };\n  }\n\n  public evict(query: Cache.EvictOptions): Cache.EvictionResult {\n    throw new Error(`eviction is not implemented on InMemory Cache`);\n  }\n\n  public reset(): Promise<void> {\n    this.data.clear();\n    this.broadcastWatches();\n\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(id: string) {\n    // Throw away optimistic changes of that particular mutation\n    const toPerform = this.optimistic.filter(item => item.id !== id);\n\n    this.optimistic = [];\n\n    // Re-run all of our optimistic data actions on top of one another.\n    toPerform.forEach(change => {\n      this.recordOptimisticTransaction(change.transaction, change.id);\n    });\n\n    this.broadcastWatches();\n  }\n\n  public performTransaction(transaction: Transaction<NormalizedCacheObject>) {\n    // TODO: does this need to be different, or is this okay for an in-memory cache?\n\n    let alreadySilenced = this.silenceBroadcast;\n    this.silenceBroadcast = true;\n\n    transaction(this);\n\n    if (!alreadySilenced) {\n      // Don't un-silence since this is a nested transaction\n      // (for example, a transaction inside an optimistic record)\n      this.silenceBroadcast = false;\n    }\n\n    this.broadcastWatches();\n  }\n\n  public recordOptimisticTransaction(\n    transaction: Transaction<NormalizedCacheObject>,\n    id: string,\n  ) {\n    this.silenceBroadcast = true;\n\n    const patch = record(this.extract(true), recordingCache => {\n      // swapping data instance on 'this' is currently necessary\n      // because of the current architecture\n      const dataCache = this.data;\n      this.data = recordingCache;\n      this.performTransaction(transaction);\n      this.data = dataCache;\n    });\n\n    this.optimistic.push({\n      id,\n      transaction,\n      data: patch,\n    });\n\n    this.silenceBroadcast = false;\n\n    this.broadcastWatches();\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    if (this.addTypename) {\n      let result = this.typenameDocumentCache.get(document);\n      if (!result) {\n        this.typenameDocumentCache.set(\n          document,\n          (result = addTypenameToDocument(document)),\n        );\n      }\n      return result;\n    }\n    return document;\n  }\n\n  public readQuery<QueryType, TVariables = any>(\n    options: DataProxy.Query<TVariables>,\n    optimistic: boolean = false,\n  ): QueryType {\n    return this.read({\n      query: options.query,\n      variables: options.variables,\n      optimistic,\n    });\n  }\n\n  public readFragment<FragmentType, TVariables = any>(\n    options: DataProxy.Fragment<TVariables>,\n    optimistic: boolean = false,\n  ): FragmentType | null {\n    return this.read({\n      query: this.transformDocument(\n        getFragmentQueryDocument(options.fragment, options.fragmentName),\n      ),\n      variables: options.variables,\n      rootId: options.id,\n      optimistic,\n    });\n  }\n\n  public writeQuery<TData = any, TVariables = any>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>,\n  ): void {\n    this.write({\n      dataId: 'ROOT_QUERY',\n      result: options.data,\n      query: this.transformDocument(options.query),\n      variables: options.variables,\n    });\n  }\n\n  public writeFragment<TData = any, TVariables = any>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>,\n  ): void {\n    this.write({\n      dataId: options.id,\n      result: options.data,\n      query: this.transformDocument(\n        getFragmentQueryDocument(options.fragment, options.fragmentName),\n      ),\n      variables: options.variables,\n    });\n  }\n\n  protected broadcastWatches() {\n    if (!this.silenceBroadcast) {\n      const optimistic = this.optimistic.length > 0;\n      this.watches.forEach((c: Cache.WatchOptions) => {\n        this.maybeBroadcastWatch(c);\n        if (optimistic) {\n          // If we're broadcasting optimistic data, make sure we rebroadcast\n          // the real data once we're no longer in an optimistic state.\n          (this.maybeBroadcastWatch as OptimisticWrapperFunction<\n            (c: Cache.WatchOptions) => void\n          >).dirty(c);\n        }\n      });\n    }\n  }\n\n  // This method is wrapped in the constructor so that it will be called only\n  // if the data that would be broadcast has changed.\n  private maybeBroadcastWatch(c: Cache.WatchOptions) {\n    const previousResult = c.previousResult && c.previousResult();\n\n    const newData = this.diff({\n      query: c.query,\n      variables: c.variables,\n      previousResult,\n      optimistic: c.optimistic,\n    });\n\n    if (previousResult &&\n        previousResult === newData.result) {\n      return;\n    }\n\n    c.callback(newData);\n  }\n}\n"],"names":["isTest","warnOnceInDevelopment","wrap","QueryDocumentKeys","getQueryDefinition","assign","getDefaultValues","isEqual","getMainDefinition","getFragmentDefinitions","createFragmentMap","shouldInclude","isField","resultKeyNameFromField","isInlineFragment","argumentsObjectFromField","getDirectiveInfoFromField","isIdValue","getStoreKeyName","toIdValue","isJsonValue","hasOwn","defaultNormalizedCacheFactory","print","getOperationDefinition","isProduction","storeKeyNameFromField","__extends","addTypenameToDocument","getFragmentQueryDocument","ApolloCache"],"mappings":"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"}